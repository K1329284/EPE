

// Close this {
var hyper = false;
var canDie = true;
var noclip = false;
var victory = false;
var epeFileMode = true;
var mouseIsPressed;
var g = function(){};
var gName = "Path";
var arrow_head_size = 700;
var isOnMenu = false;
var ctime = millis();
var ptime = millis();
var start = millis();
var nothing, nil, empty, undef, noth, None, none;
var NOTHING, NIL, EMPTY, UNDEF, NOTHING, NONE, UNDEFINED;
var freecamMode = false;
var no = false, NO = false, yes = true, YES = true;
var showText = true;
var lastKeycode = "";
var inworm = false;
var inwormp = false;
var inkey = false;
var inkeyp = false;
var elasticPower = {x:0, y:0};
var selectPos1 = {xpos:0, ypos:0};
var selectPos2 = {xpos:0, ypos:0};
var COLOR = {
    WALL : color(100),
    STONE : color(100),
    
    ERASER : color(255, 166, 0),
    LAVA : color(255, 166, 0),
    
    HOLE : color(87, 58, 9),
    DIRT : color(87, 58, 9),
    
    VOID : color(-100,-100,-100),
    
    CHECKPOINT : color(117, 235, 106),
    
    MUD : color(107, 87, 52),
    
    ICE : color(135, 232, 227),
    
    BOOSTER : color(224, 224, 97),
    
    TRAMPOLINE : color(164, 70, 214),
    
    TELEPORTER : color(56, 235, 235),
    DIAMOND : color(56, 235, 235),
    
    SULFUR : color(73, 74, 39),
    CONVEYOR : color(73, 74, 39),
    
    LOCKED_PLATFORM : color(194),
    SILVER : color(194),
    
    GOLD : color(255, 213, 0),
    KEY : color(255, 213, 0),
    
    LOCKED_WALL : color(80),
    BASALT : color(80),
    
    LOCKED_ERASER : color(219, 69, 0),
    MAGMA : color(219, 69, 0),
    
    WORMHOLE : color(83, 0, 125),
    OBSIDIAN : color(83, 0, 125),
    
    FAINT : color(128,128,128,20),
    
    TELEPORTER_TO : color(0, 160, 255),
    OCEAN : color(0, 160, 255),
    
    WIN : color(255,240,200),
    AETHER : color(255,240,200),
    
    BLACK : color(0),
    GRAY : color(128),
    WHITE : color(255),
    
    RED : color(255, 0, 0),
    ORANGE : color(255, 128, 0),
    YELLOW : color(255, 255, 0),
    CHART : color(180, 255, 0),
    GREEN : color(0, 255, 0),
    JADE : color(0, 255, 160),
    CYAN : color(0, 255, 255),
    AZURE : color(0, 160, 255),
    BLUE : color(0, 0, 255),
    PURPLE : color(140, 0, 255),
    MAGENTA : color(255, 0, 255),
    ROSE : color(255, 0, 128),
    
    PINK : color(255, 128, 128),
    TAN : color(225, 200, 150),
    BROWN : color(128, 64, 32),
};
//{


// Chapter One Record: 2:14:500

//{
var keys = [], pkeys = [], pressed = false, released = false, mouseWasPressed = false;

var W = 87, A = 65, S = 83, D = 68, Q = 81, E = 69, Z = 90, X = 86, C = 67, R = 82, F = 70, V = 86, T = 84, Y = 89, U = 85, I = 73, O = 79, P = 80, G = 71, H = 72, J = 74, K = 75, L = 76, B = 66, M = 78, N = 77, SPACE = 32, OPEN_BRACKET = 219, CLOSED_BRACKET = 221;

for(var i = 0; i < 256; i++){
    keys.push(false);
}

function isDown(KEY){
    return keys[KEY];
}

function wasPressed(KEY){
    return keys[KEY] && !pkeys[KEY];
}

function wasReleased(KEY){
    return !keys[KEY] && pkeys[KEY];
}

function mousePressed(){
    mouseIsPressed = true;
}

function YouNeedToRunThisEachFrameItMakesTheInputWork(){
    if(pressed){
        pressed = false;
    }
    
    if(released){
        released = false;
    }
    
    pkeys = [];
    
    for(var i = 0; i < 256; i++){
        pkeys[i] = keys[i];
    }
    
    mouseWasPressed = mouseIsPressed;
}

var x1,x2,y1,y2;
keyPressed = function(){
    keys[keyCode] = true;
    pressed = keyCode;
};
keyReleased = function(){
    keys[keyCode] = false;
    released = keyCode;
    
    if(keyCode === CONTROL){
        println("(" + (x1-width)/5 + "," + (y1-height)/5 + "," + (x2-x1)/5 + "," + (y2-y1)/5 + ")" + (epeFileMode ? "" : ";"));
    }
    else if(keyCode === ALT){
        if(!epeFileMode){
            println(gName + "(" + (x1-width)/5 + "," + (y1-height)/5 + "," + (x2-x1)/5 + "," + (y2-y1)/5 + ");");
            if(debugMode){
                g((x1-width)/5, (y1-height)/5, (x2-x1)/5, (y2-y1)/5);
            }
        }
        else{
            println(gName.toUpperCase() + " (" + (x1-width)/5 + " " + (y1-height)/5 + " " + (x2-x1)/5 + " " + (y2-y1)/5 + ")");
            if(debugMode){
                g((x1-width)/5, (y1-height)/5, (x2-x1)/5, (y2-y1)/5);
            }
        }
    }
};
//} Evan\'s Toolkit
//{
var timeToRespawn = 30;
var pS = 30; // Player size (only visual)
var speed = 1.1*player_walking_speed; // Player speed
var G = 0.1*gravity_strength; // Gravity
//} Gamerules
//{
//{
var boxes = [];
var floors = [];
var textboxes = [];
var foreground = [];
var time;
var frames = 0;
var millistart = millis();
var player = {xpos:player_starting_x_position, ypos:player_starting_y_position, zpos:0, vel:0, alive:true, respawnTimer:timeToRespawn, spawnX:  player_starting_x_position, spawnY:  player_starting_y_position, spawnID: -1};
var oldplayer = {xpos:0, ypos:0};
var justLanded = 0;
var buffer = -5;
var deaths = 0;
var index;
var dx = 0, dy = 0, dz = 0, colli;
var b; var newColor;
//} Variable Declaration

//{
var notiTime = 3000; var notiText = "WASD to move, space to jump.";
function setNotification(noti){
    notiText = noti;
    notiTime = 1000;
}
function drawNotification(){
    notiTime -= 5;
    textSize(20);
    textAlign(LEFT, TOP);
    fill(255, 255, 255, notiTime);
    for(var i = -1; i <= 1; i++){
        for(var j = -1; j <= 2; j++){
            text(notiText, 5+i, 0+j);
        }
    }
    
    fill(0, 0, 0, notiTime);
    text(notiText, 5, 0);
}
//} Notifications

//{

function setTitle(noti){
    titleText = noti;
    titleTime = 1500;
}
function drawTitle(){
    titleTime -= 5;
    textSize(30);
    textAlign(CENTER, CENTER);
    fill(0,0,0,titleTime);
    noStroke();
    rect(0,0,width,height);
    fill(255, 255, 255, titleTime);
    text(titleText, width/2, height/2);
}
//}

function unlock(keycode){
    for(var i = 0; i < boxes.length; i++){
        b = boxes[i];
        if(b.isLock && b.keycode === keycode){
            if(b.isLPlat){
                b.vanished = false;
            }
            else{
                b.canBeJumped = true;
                b.coll = false;
            }
        }
    }
}
function relock(keycode){
    for(var i = 0; i < boxes.length; i++){
        b = boxes[i];
        if(b.isLock && b.keycode === keycode){
            if(b.isLPlat){
                b.vanished = true;
            }
            else{
                b.canBeJumped = false;
                b.coll = true;
            }
        }
    }
}

//} Starting Variables
//{
function Textbox(x,y,message,ts,c){
    textboxes.push({xpos:x, ypos:y, message:message, textsize:ts ? ts : 30, color:c ? c : COLOR.BLACK});
}
function Box(x,y,w,h,col,coll,jumpable,deadly,message,isACheckpoint){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:jumpable, width:w, height:h, color:col, coll:coll, kills:deadly, isCheckpoint:isACheckpoint, message:message});
}
function Wall(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w*5, height:h*5, color:c ? c : COLOR.WALL, coll:true, kills:false, isCheckpoint:false});
}
function Platform(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w*5, height:h*5, color:c ? c : COLOR.WALL, coll:false, kills:false, isCheckpoint:false});
}
function Hurdle(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w*5, height:h*5, color:c ? c : COLOR.WALL, coll:true, kills:false, isCheckpoint:false});
}
function Path(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w*5, height:h*5, color:c ? c : COLOR.WALL, coll:false, kills:false, isCheckpoint:false});
}
function Eraser(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w*5, height:h*5, color:c ? c : COLOR.LAVA, coll:true, kills:true, isCheckpoint:false});
}
function Hole(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w*5, height:h*5, color:c ? c : COLOR.HOLE, coll:false, kills:true, isCheckpoint:false});
}
function Void(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w*5, height:h*5, color:c ? c : COLOR.VOID, coll:false, kills:true, isCheckpoint:false});
}
function Checkpoint(x,y,m,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 80, height:h ? h*5 : 80, color:c ? c : COLOR.CHECKPOINT, coll:false, kills:false, isCheckpoint:true, message:m, textTrigger:false});
}
function ForcedCheckpoint(x,y,m,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 80, height:h ? h*5 : 80, color:c ? c : COLOR.CHECKPOINT, coll:false, kills:false, isCheckpoint:true, message:m, textTrigger:false});
}
function Mud(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w*5, height:h*5, color:c ? c : COLOR.MUD, coll:false, kills:false, isCheckpoint:false, slows:true});
}
function ForcedMud(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w*5, height:h*5, color:c ? c : COLOR.MUD, coll:false, kills:false, isCheckpoint:false, slows:true});
}
function Ice(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w*5, height:h*5, color:c ? c : COLOR.ICE, coll:false, kills:false, isCheckpoint:false, ice:true});
}
function ForcedIce(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w*5, height:h*5, color:c ? c : COLOR.ICE, coll:false, kills:false, isCheckpoint:false, ice:true});
}
function Booster(x,y,w,h,boost,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w*5, height:h*5, color:c ? c : COLOR.BOOSTER, coll:false, kills:false, isCheckpoint:false, boosts:true,boostPower:(boost ? boost : 0.1)});
}
function ForcedBooster(x,y,w,h,boost,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w*5, height:h*5, color:c ? c : COLOR.BOOSTER, coll:false, kills:false, isCheckpoint:false, boosts:true,boostPower:(boost ? boost : 0.1)});
}
function TeleporterIn(x,y,tc,w,h,c,i){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TELEPORTER, coll:false, kills:false, isCheckpoint:false, slows:false, tpc:tc, tpDir:"in", isInvisible:i ? i : false});
}
function TeleporterOut(x,y,tc,w,h,c,i){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TELEPORTER, coll:false, kills:false, isCheckpoint:false, slows:false, tpc:tc, tpDir:"out", isInvisible:i ? i : false});
}
function TeleporterOutA(x,y,tc,w,h,c,i){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TELEPORTER, coll:false, kills:false, isCheckpoint:false, slows:false, tpc:tc, tpDir:"out", isExact:true, isInvisible:i ? i : false});}
function TeleporterInForced(x,y,tc,w,h,c,i){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TELEPORTER, coll:false, kills:false, isCheckpoint:false, slows:false, tpc:tc, tpDir:"in", isInvisible:i ? i : false});
}
function Trampoline(x,y,w,h,jm,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TRAMPOLINE, coll:false, kills:false, slows:false, isTrampoline:true, jumpFactor:jm ? jm : 1});
}
function Key(keycode,x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 30, height:h ? h*5 : 30, color:c ? c : COLOR.GOLD, coll:false, kills:false, keycode:keycode, isKey:true, isLock:false});
}
function LockedWall(keycode,x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.BASALT, coll:true, kills:false, keycode:keycode, isKey:false, isLock:true});
}
function LockedEraser(keycode,x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.MAGMA, coll:false, kills:true, keycode:keycode, isKey:false, isLock:true});
}
function LockedPlatform(keycode,x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.SILVER, coll:false, kills:false, keycode:keycode, isKey:false, isLock:true, vanished:true, isLPlat:true});
}
function TeleporterTo(x,y,w,h,nx,ny,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.OCEAN, coll:false, kills:false, gotoX : round(nx*5), gotoY : round(ny*5), isTT: true});
}
function ForcedTeleporterTo(x,y,w,h,nx,ny,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.OCEAN, coll:false, kills:false, gotoX : round(nx*5), gotoY : round(ny*5), isTT: true});
}
function Wormhole(x,y,whc,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.OBSIDIAN, coll:false, kills:false, wormholeCode:whc});
}
function ForcedWormhole(x,y,whc,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.OBSIDIAN, coll:false, kills:false, wormholeCode:whc});
}
function ElasticWall(x,y,w,h,power,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.PINK, coll:false, kills:false, isElastic:true, power: power ? power : 2});
}
function Conveyor(x,y,w,h,xspd,yspd,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.SULFUR, coll:false, kills:false, isConveyor:true, xConv:xspd, yConv:yspd});
}
function ForcedConveyor(x,y,w,h,xspd,yspd,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.SULFUR, coll:false, kills:false, isConveyor:true, xConv:xspd, yConv:yspd});
}

function MovingBox(x,y,w,h,col,coll,jumpable,deadly,message,isACheckpoint,moveSpeed,moveDistance,moveVert,slows,ice,boosts,boost){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:jumpable, width:w*5, height:h*5, color:col, coll:coll, kills:deadly, isCheckpoint:isACheckpoint, message:message, moveSpeed:moveSpeed, moveDistance:moveDistance,slows:slows,hasTraveled:0,dir:1,doesMove:true,trueX:x*5,trueY:y*5,moveVert:moveVert,boosts:(boosts ? true : false),boostPower:(boost ? boost : 0.1),ice:ice});
}

//{

function MovingWall(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.WALL,
    true/*collides*/,
    false/*jumpable*/,
    false/*kills*/,
    undefined/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV
    );
}
function MovingPlatform(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.WALL,
    false/*collides*/,
    false/*jumpable*/,
    false/*kills*/,
    undefined/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV
    );
}
function MovingPath(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.WALL,
    false/*collides*/,
    true/*jumpable*/,
    false/*kills*/,
    undefined/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV
    );
}
function MovingHurdle(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.WALL,
    true/*collides*/,
    true/*jumpable*/,
    false/*kills*/,
    undefined/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV
    );
}
function MovingEraser(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.LAVA,
    true/*collides*/,
    false/*jumpable*/,
    true/*kills*/,
    undefined/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV
    );
}
function MovingHole(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.HOLE,
    true/*collides*/,
    true/*jumpable*/,
    true/*kills*/,
    undefined/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV
    );
}
function MovingVoid(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.VOID,
    true/*collides*/,
    true/*jumpable*/,
    true/*kills*/,
    undefined/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV
    );
}
function MovingCheckpoint(x,y,m,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.CHECKPOINT,
    false/*collides*/,
    true/*jumpable*/,
    false/*kills*/,
    m/*message*/,
    true/*isCheckpoint*/,
    mT,
    mD,mV
    );
}
function MovingForcedCheckpoint(x,y,m,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.CHECKPOINT,
    false/*collides*/,
    false/*jumpable*/,
    false/*kills*/,
    m/*message*/,
    true/*isCheckpoint*/,
    mT,
    mD,mV
    );
}
function MovingMud(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.MUD,
    false/*collides*/,
    true/*jumpable*/,
    false/*kills*/,
    false/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV,
    true/*slows*/
    );
}
function MovingForcedMud(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.MUD,
    false/*collides*/,
    false/*jumpable*/,
    false/*kills*/,
    false/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV,
    true/*slows*/
    );
}
function MovingIce(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.ICE,
    false/*collides*/,
    true/*jumpable*/,
    false/*kills*/,
    false/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV,
    false,/*slows*/
    true/*ice*/
    );
}
function MovingForcedIce(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.ICE,
    false/*collides*/,
    false/*jumpable*/,
    false/*kills*/,
    false/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV,
    false,/*slows*/
    true/*ice*/
    );
}
function MovingBooster(x,y,w,h,mT,mD,mV,bp,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.BOOSTER,
    false/*collides*/,
    true/*jumpable*/,
    false/*kills*/,
    false/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV,
    false,/*slows*/
    false,/*ice*/
    true,/*boosts*/
    bp/*boost power in %*/
    );
}
function MovingForcedBooster(x,y,w,h,mT,mD,mV,bp,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.BOOSTER,
    false/*collides*/,
    false/*jumpable*/,
    false/*kills*/,
    false/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV,
    false,/*slows*/
    false,/*ice*/
    true,/*boosts*/
    bp/*boost power in %*/
    );
}
function MovingTeleporterIn(x,y,tc,w,h,mT,mD,mV,c,i){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TELEPORTER, coll:false, kills:false, isCheckpoint:false, slows:false, tpc:tc, tpDir:"in", isInvisible:i ? i : false, moveSpeed:mT, moveDistance:mD,hasTraveled:0,dir:1,doesMove:true,trueX:x*5,trueY:y*5,moveVert:mV});
}
function MovingTeleporterOut(x,y,tc,w,h,mT,mD,mV,c,i){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TELEPORTER, coll:false, kills:false, isCheckpoint:false, slows:false, tpc:tc, tpDir:"out", isInvisible:i ? i : false, moveSpeed:mT, moveDistance:mD,hasTraveled:0,dir:1,doesMove:true,trueX:x*5,trueY:y*5,moveVert:mV});
}
function MovingTeleporterOutA(x,y,tc,w,h,mT,mD,mV,c,i){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TELEPORTER, coll:false, kills:false, isCheckpoint:false, slows:false, tpc:tc, tpDir:"out", isExact:true, isInvisible:i ? i : false, moveSpeed:mT, moveDistance:mD,hasTraveled:0,dir:1,doesMove:true,trueX:x*5,trueY:y*5,moveVert:mV});}
function MovingTeleporterInForced(x,y,tc,w,h,mT,mD,mV,c,i){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TELEPORTER, coll:false, kills:false, isCheckpoint:false, slows:false, tpc:tc, tpDir:"in", isInvisible:i ? i : false, moveSpeed:mT, moveDistance:mD,hasTraveled:0,dir:1,doesMove:true,trueX:x*5,trueY:y*5,moveVert:mV});
}
function MovingTrampoline(x,y,w,h,mT,mD,mV,jm,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TRAMPOLINE, coll:false, kills:false, slows:false, isTrampoline:true, jumpFactor:jm ? jm : 1, moveSpeed:mT, moveDistance:mD,hasTraveled:0,dir:1,doesMove:true,trueX:x*5,trueY:y*5,moveVert:mV});
}
function MovingKey(keycode,x,y,w,h,mT,mD,mV,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 30, height:h ? h*5 : 30, color:c ? c : COLOR.GOLD, coll:false, kills:false, keycode:keycode, isKey:true, isLock:false, moveSpeed:mT, moveDistance:mD,hasTraveled:0,dir:1,doesMove:true,trueX:x*5,trueY:y*5,moveVert:mV});
}
function Win(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 30, height:h ? h*5 : 30, color:c ? c : COLOR.AETHER, coll:false, kills:false, isWin:true});
}
//} Every box creator

//{
function TextTrigger(x,y,m,w,h){
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 80, height:h ? h*5 : 80, color:color(255, 255, 255,0), coll:false, kills:false, isCheckpoint:false, message:m, isTextTrigger:true});
}
//} Triggers

//{
function Floor(x,y,w,h,c){
    floors.push({xpos:x*5, ypos:y*5, width:w*5, height:h*5, color:c ? c : COLOR.SILVER});
}
function Fog(){
    
}
//} Floors

//} Object Creators




//{
var flickerLifetime, progress;
function flickerCurrentlyExists(boxToCheck){
    flickerLifetime = boxToCheck.existingTime + boxToCheck.missingTime;
    progress = frames % flickerLifetime;
    
    return progress < boxToCheck.existingTime;
}
var xmove = 0, ymove = 0, zmove, iters, pdz, foo, move, xOffset, yOffset, shrinkage; var cx1, cy1, cx2, cy2;
function drawBox(i){
    b = boxes[i];
    if((b.xpos < player.xpos + width/2 && b.xpos + b.width > player.xpos - width/2 && b.ypos < player.ypos + height/2 && b.ypos + b.height > player.ypos - height/2) || freecamMode){ // If box is close enough to matter
    if(!b.isInvisible && (!b.flickers || flickerCurrentlyExists(b))){
        if(!b.vanished){
            fill(b.color);
            strokeWeight(5);
            if(!b.isTextTrigger){
                stroke(lerpColor(b.color,color(255*(b.canBeJumped ? 1 : 0)),0.3));
            }
            else{
                noStroke();
                if(debugMode){
                    stroke(255,255,255);
                    strokeWeight(5);
                }
            }
        }
        else{
            fill(COLOR.FAINT);
            stroke(COLOR.FAINT);
            strokeWeight(5);
        }
        
        rect(b.xpos - player.xpos + width/2, b.ypos - player.ypos + height/2, b.width, b.height,5);
        
        
        if(do_draw_linking_codes && showText){
            textAlign(CENTER, CENTER);
            textSize(15);
            fill(0);
            if(b.keycode !== undefined){
                text(b.keycode, b.xpos - player.xpos + width/2 + b.width/2, b.ypos - player.ypos + height/2 + b.height/2);
            }
            else if(b.tpc !== undefined){
                text(b.tpc, b.xpos - player.xpos + width/2 + b.width/2, b.ypos - player.ypos + height/2 + b.height/2);
            }
            else if(b.wormholeCode !== undefined){
                text(b.wormholeCode, b.xpos - player.xpos + width/2 + b.width/2, b.ypos - player.ypos + height/2 + b.height/2);
            }
        }
        if(b.isConveyor){
            cx1 = b.xpos - player.xpos + width/2 + b.width/2;
            cy1 = b.ypos - player.ypos + height/2 + b.height/2;
            cx2 = cx1 + b.xConv*10;
            cy2 = cy1 + b.yConv*10;
            
            var angle = atan2(cy2 - cy1, cx2 - cx1); 
            
            strokeWeight(10);
            stroke(0, 0, 0);
            line(cx1, cy1, cx2, cy2);
            line(cx2, cy2, cx2 - 10*cos(angle + 45), cy2 - 10*sin(angle + 45));
            line(cx2, cy2, cx2 - 10*cos(angle - 45), cy2 - 10*sin(angle - 45));
            strokeWeight(5);
            stroke(255, 255, 255);
            line(cx1, cy1, cx2, cy2);
            line(cx2, cy2, cx2 - 10*cos(angle + 45), cy2 - 10*sin(angle + 45));
            line(cx2, cy2, cx2 - 10*cos(angle - 45), cy2 - 10*sin(angle - 45));
        }
    }
    }
    if(b.isTT){
        textSize(15);
        fill(0, 0, 0);
                text("(" + b.gotoX/5 + ", " + b.gotoY/5 + ")", b.xpos - player.xpos + width/2 + b.width/2, b.ypos - player.ypos + height/2 + b.height/2);
                text("(" + b.gotoX/5 + ", " + b.gotoY/5 + ")", b.gotoX - player.xpos + width/2 + b.width/2 - 50, b.gotoY - player.ypos + height/2 + b.height/2 - 50);
            }
}
var f;
function drawFloor(i){
    f = floors[i];
    fill(f.color);
    noStroke();
    rect(f.xpos - player.xpos + width/2, f.ypos - player.ypos + height/2, f.width, f.height);
}
var playerInside = false;
function checkCollision(i){
    b = boxes[i];
    
    playerInside = !noclip && (b.xpos+buffer < player.xpos && player.xpos < b.xpos + b.width-buffer &&
    b.ypos+buffer < player.ypos && player.ypos < b.ypos + b.height-buffer);
    
    return playerInside && !b.vanished && (!b.flickers || flickerCurrentlyExists(b));
}
function checkCollisions(){
    if(freecamMode){
        return {};
    }
    for(var i = boxes.length - 1; i >= 0 ; i--){
        if(checkCollision(i)){
            return {
                collided:b.coll && (player.zpos > 2 ? !b.canBeJumped : true),
                killed:b.kills && (player.zpos > 2 ? !b.canBeJumped : true), 
                checkpoint:b.isCheckpoint,
                wasJumpable:b.canBeJumped && b.coll && (player.zpos > 2 ? !b.canBeJumped : true) && (!b.flickers || flickerCurrentlyExists(b)),
                
                boxID:i,
                
                slows:!!b.slows && (player.zpos > 2 ? !b.canBeJumped : true),
                noFriction: b.ice && (player.zpos > 2 ? !b.canBeJumped : true),
                boosted: b.boosts && (player.zpos > 2 ? !b.canBeJumped : true),
                boostPower: b.boostPower*(player.zpos > 2 ? !b.canBeJumped : true),
                moved:!!b.doesMove && (player.zpos < 2) && (!b.flickers || flickerCurrentlyExists(b)),
                isWall:b.coll && !b.kills && !b.canBeJumped,
                movingVertical:!!b.moveVert,
                moveSpeed:b.moveSpeed,
                moveDirection:b.dir,
                advMoved:!!b.advMoving && (player.zpos < 2) && (!b.flickers || flickerCurrentlyExists(b)),
            };
        }
        
    }
    return {collided:false, killed:false, checkpoint:false};
}
/*
Here I would like to define two term.
Pre-ironing collision and post-ironing collision.

"Ironing" here is the process of returning the collision object with all the data shown above.

If something collides "pre-ironed" then it will have an object returned about it, but if it does not then it will not.

When jumping over an object the player still collides with it, but the "ironing" corrects this. This nuance allows for ToForced() objects to exists and not exist.

Although jumping is a "post-ironing" collision issue, a ToFlickering() object is actually "pre-ironed" out to prevent collision issues. (Which otherwise do happen)

One question you may have is "Why is everything not pre-ironed?" and there are two answers.
1. "Pre-ironing" calculations are done PER OBJECT so any addition could easily begin to slow down performance. Returning the top-most object where the player is even if they are not touching it is fine since the calculation for it can be done a single time during "post-ironing".
2. Getting the object below the player even when not touched allows the differentiation between Forced and not Forced objects.
*/

function unlock(keycode){
    for(var i = 0; i < boxes.length; i++){
        b = boxes[i];
        if(b.isLock && b.keycode === keycode){
            if(b.isLPlat){
                b.vanished = false;
            }
            else{
                b.canBeJumped = true;
                b.coll = false;
            }
        }
    }
}
function relock(keycode){
    for(var i = 0; i < boxes.length; i++){
        b = boxes[i];
        if(b.isLock && b.keycode === keycode){
            if(b.isLPlat){
                b.vanished = true;
            }
            else{
                b.canBeJumped = false;
                b.coll = true;
            }
        }
    }
}
var camX = width/2, camY = height/2;
function drawPlayer(){
    strokeWeight(5);
    fill(255*(canDie && !noclip), 255*(noclip), 255*(!canDie && !noclip), pow((255 - player.zpos)/255,1.5)*255);
    stroke(168*(canDie && !noclip), 168*(noclip), 168*(!canDie && !noclip), pow((255 - player.zpos)/255,1.5)*255);
    strokeWeight((5 + justLanded*5)*player.respawnTimer/timeToRespawn);
    if(!freecamMode){
        camX = lerp(camX, width/2 + xmove, 0.2);
        camY = lerp(camY, height/2 + ymove, 0.2);
        ellipse(camX, camY, (pS + player.zpos)*player.respawnTimer/timeToRespawn, (pS + player.zpos)*player.respawnTimer/timeToRespawn);
    }
    else{
        ellipse(camX - player.xpos, camY - player.ypos, (pS + player.zpos)*player.respawnTimer/timeToRespawn, (pS + player.zpos)*player.respawnTimer/timeToRespawn);
    }
    
    justLanded -= 1;
    
    if(hyper){
        fill(0,0,0,0);
        stroke(255,100);
        strokeWeight(30);
        for(var i = 3; i < 5; i++){
            ellipse(camX, camY, i*30, i*30);
        }
    }
}
var next_color = color(255,0,0), current_color = color(255,0,0);
function displayTime(){
    stroke(1);
    strokeWeight(1);
    if(show_timer || show_deaths){
        fill(230, 230, 230);
        rect(width-61,0,60,4 + 10*(show_timer + show_deaths));
        fill(0, 0, 0);
        textSize(12);
        textAlign(CENTER, CENTER);
        time = millis() - millistart;
        if(show_timer){
            text(floor(time/1000/60)+":"+(floor(time/1000%60) < 10 ? "0" : "")+floor(time/1000%60)+":"+floor(time%1000), width-30, 8);
        }
        if(show_deaths){
            fill(200, 0, 0);
            text(deaths + " deaths", width-30, 18 - 10*!show_timer);
        }
    }
    
    // If drops below 15fps
    if(ctime - ptime > 66 && print_lag_spikes){
        println("Lag spike: " + round(ctime - ptime));
    }
    
    if(show_performance){
        next_color = color(pow((ctime - ptime)/17, 5)*255, 0, 0);
        current_color = lerpColor(current_color, next_color, 0.08);
        fill(current_color);
        rect(width - 21, 4*(show_timer || show_deaths) + 10*(show_timer + show_deaths), 20, 20);
    }
}

function drawTestBox(){
    x1 = min(selectPos1.xpos,selectPos2.xpos)*5;
    x2 = max(selectPos1.xpos,selectPos2.xpos)*5;
    y1 = min(selectPos1.ypos,selectPos2.ypos)*5;
    y2 = max(selectPos1.ypos,selectPos2.ypos)*5;
    
    stroke(255,0,0,100);
    fill(0,255,0,100);
    strokeWeight(5);
    rect(x1 - player.xpos - width/2,y1 - player.ypos - height/2,x2-x1,y2-y1,5);
}
var textbox; var progress; var oldX, oldY;
function drawGame(){
    for(var i = 0; i < floors.length; i++){
        drawFloor(i);
    }
    for(var i = 0; i < boxes.length; i++){
        b = boxes[i];
        if(b.crumbles){
            if(b.width > 0 && b.wasSteppedOn){
                b.xpos += b.crumbleSpeedX/2;
                b.ypos += b.crumbleSpeedY/2;
                b.width -= b.crumbleSpeedX;
                b.height -= b.crumbleSpeedY;
                if(b.width <= 0){
                    b.timer = b.crumbleTime;
                }
                b.width = constrain(b.width, 0, b.maxWidth);
                b.height = constrain(b.height, 0, b.maxHeight);
                if(b.width <= 0){
                    b.timer = b.crumbleTime*5;
                    b.isInvisible = true;
                }
            }
            else if(b.wasSteppedOn){
                b.timer -= 1;
                if(b.timer < 0){
                    b.width = b.maxWidth;
                    b.height = b.maxHeight;
                    b.xpos -= b.maxWidth/2;
                    b.ypos -= b.maxHeight/2;
                    b.timer = b.crumbleTime*5;
                    b.wasSteppedOn = false;
                    b.isInvisible = false;
            }
        }
        }
        if(b.doesMove){
            if(b.advMoving){
                progress = (millis() % (4*b.travelTime))/b.travelTime;    
                progress = (progress % 2 - 1) * (progress > 2 ? 1 : -1);
                b.dir = progress > 1 ? 1 : -1;
                
                oldX = b.xpos;
                oldY = b.ypos;
                
                b.xpos = b.trueX + progress*b.xSpeed*b.travelTime;
                b.ypos = b.trueY + progress*b.ySpeed*b.travelTime;
                
                b.xmoved = oldX - b.xpos;
                b.ymoved = oldY - b.ypos;
            }
            else{
                if(b.hasTraveled > b.moveDistance*5){
                    b.dir = -1;
                }
                if(b.hasTraveled < 0){
                    b.dir = 1;
                }
                b.hasTraveled += b.dir*b.moveSpeed;
                
                if(b.moveVert){
                    b.ypos = b.trueY + b.hasTraveled;
                }
                else{
                    b.xpos = b.trueX + b.hasTraveled;
                }
            }
        }
        drawBox(i);
    }
    drawPlayer();
    drawTestBox();
    drawNotification();
    drawTitle();
    
    if(showText){
        textAlign(CENTER, CENTER);
        for(var i = 0; i < textboxes.length; i++){
            textbox = textboxes[i];
            if((player.xpos < textbox.xpos*5 + width * player.xpos > textbox.xpos*5 - width) || freecamMode){
                fill(textbox.color);
                textSize(textbox.textsize);
                text(textbox.message, textbox.xpos*5 - player.xpos + width/2, textbox.ypos*5 - player.ypos + height/2);
            }
        }
    }
    displayTime();
}
function killPlayer(){
    if(canDie){
        player.alive = false;
        player.respawnTimer = timeToRespawn;
        dx = 0;
        dy = 0;
        dz = 0;
        elasticPower.x = 0;
        elasticPower.y = 0;
        deaths += 1;
    }
}
function mousePosToRealPos(){
    return {xpos:round((mouseX + player.xpos + width/2)/5), ypos:round((mouseY + player.ypos + height/2)/5)};
}

var colliBox;
function keyboardControl(){
    colli = checkCollisions();
    colliBox = boxes[colli.boxID];
    
    
    if(colli.moved || (colli.isWall && b.moveSpeed !== undefined)){ 
        if(colli.advMoved){
            player.xpos -= colliBox.xmoved;
            player.ypos -= colliBox.ymoved;
        }
        else if(colli.movingVertical){
            player.ypos += b.dir*b.moveSpeed*1;
        }
        else{
            player.xpos += b.dir*b.moveSpeed*1;
        }
        
        
    }
    
    if((isDown(SHIFT) || isDown(SPACE)) && player.zpos < 1){
        dz = 3;
    }
    if(isDown(LEFT) || isDown(A)){
        dx += -1 * (hyper ? 5 : 1);}
    if(isDown(RIGHT) || isDown(D)){
        dx += 1 * (hyper ? 5 : 1);}
    if(isDown(UP) || isDown(W)){
        dy += -1 * (hyper ? 5 : 1);}
    if(isDown(DOWN) || isDown(S)){
        dy += 1 * (hyper ? 5 : 1);}
    if(isDown(K)){
        killPlayer();}
    if(isDown(OPEN_BRACKET)){
        selectPos1 = mousePosToRealPos();
    }
    if(isDown(CLOSED_BRACKET)){
        selectPos2 = mousePosToRealPos();
    }
}
var colli;
var B;
function movementMath(){
    xmove = 0;
    ymove = 0;
    dx += elasticPower.x;
    dy += elasticPower.y;
    elasticPower.x *= 0.7;
    elasticPower.y *= 0.7;
    
    colli = checkCollisions();
    B = boxes[colli.boxID];
    
    if(B !== undefined && B.isTrampoline && (player.zpos < 1)){
        dz = 3*B.jumpFactor;
    }
    
    if(freecamMode){
        dx *= 0.9;
        dy *= 0.9;
    }
    else if(colli.noFriction){
        dy *= 0.97;
        dx *= 0.97;
    }
    else if(colli.slows){
        dy *= 0.4;
        dx *= 0.4;
    }
    else if(colli.boosted){
        dy *= 1 + colli.boostPower;
        dx *= 1 + colli.boostPower;
    }
    else{
        dy *= 0.8;
        dx *= 0.8;
    }
    
    if(!colli.wasJumpable){
        xmove = dx*speed;
        ymove = dy*speed;
        
        if(!freecamMode){
            if(!colli.boosted){
                if(speed_is_limited){
                    xmove = min(abs(xmove), min(6.25 + abs(elasticPower.x),50))*(xmove === 0 ? 0 : abs(xmove)/xmove);
                    ymove = min(abs(ymove), min(6.25 + abs(elasticPower.y),50))*(ymove === 0 ? 0 : abs(ymove)/ymove);
                }
            }
            else{
                if(speed_is_limited){
                    xmove = min(abs(xmove), width)*(xmove === 0 ? 0 : abs(xmove)/xmove);
                    ymove = min(abs(ymove), height)*(ymove === 0 ? 0 : abs(ymove)/ymove);
                }
            }
        }
        
        player.xpos += xmove;
        player.ypos += ymove;
    }
    dz -= G;
    
    player.zpos += dz;
    if(player.zpos < -1){
        player.dz = 0;
        player.zpos = 0;
    }
}
var m;
function specialCollision(){
    m = checkCollisions();
    foo = boxes[m.boxID];
    if(foo !== undefined){
        if(m.killed){
            killPlayer();
        }
        
        else if(foo.wormholeCode && (player.zpos > 2 ? !foo.canBeJumped : true)){
            inworm = true;
            if(!inwormp){
                for(var i = 0; i < boxes.length; i++){
                    b = boxes[i];
                    if(m.boxID !== i && b.wormholeCode === foo.wormholeCode){
                        xOffset = constrain(player.xpos - foo.xpos, 0, b.width);
                        yOffset = constrain(player.ypos - foo.ypos, 0, b.height);
                        player.xpos = b.xpos + xOffset;
                        player.ypos = b.ypos + yOffset; 
                    }
                }
            }
        }
        
        else if(foo.isCheckpoint && (player.zpos > 2 ? !foo.canBeJumped : true)){
            player.spawnX = foo.xpos + foo.width/2;
            player.spawnY = foo.ypos + foo.height/2;
            setNotification(foo.message+"");
        }
        
        else if(foo.isElastic){
            elasticPower.x -= dx*foo.power;
            elasticPower.y -= dy*foo.power;
        }
        
        else if(foo.isConveyor && (player.zpos > 2 ? !foo.canBeJumped : true)){
            dx += foo.xConv/5;
            dy += foo.yConv/5;
        }
        
        if(foo.isKey && !inkey){
            inkey = true;
            if(!foo.canBeJumped){
                unlock(foo.keycode);
                lastKeycode = foo.keycode;
                foo.canBeJumped = true;
            }
            else{
                relock(foo.keycode);
                lastKeycode = foo.keycode;
                foo.canBeJumped = false;
            }
        }
        else if(foo.isKey){
            
        }
        else{
            inkey = false;
        }
        
        if(foo.crumbles && (player.zpos > 2 ? !foo.canBeJumped : true)){
            b.wasSteppedOn = true;
        }
        
        if(foo.isTextTrigger){
            setNotification(foo.message+"");
            index = boxes.indexOf(foo);
            boxes.splice(index, 1);
        }
        else if(foo.isWin){
            victory = true;
        }
        if(foo.tpDir === "in" && foo.tpc !== 0 && (player.zpos > 2 ? !b.canBeJumped : true)){
            for(var i = 0; i < boxes.length; i++){
                if(boxes[i].tpc){
                    b = boxes[i];
                    if(b.tpDir==="out" && foo.tpc===b.tpc){
                        if(b.isExact){
                            xOffset = constrain(player.xpos - foo.xpos, 0, b.width);
                            yOffset = constrain(player.ypos - foo.ypos, 0, b.height);
                            player.xpos = b.xpos + xOffset;
                            player.ypos = b.ypos + yOffset; 
                        }
                        else{
                            player.xpos = b.xpos + b.width/2;
                            player.ypos = b.ypos + b.height/2;
                        }
                        break;
                    }
                }
                else{
                    continue;
                }
            }
        }
        else if(foo.isTT && (player.zpos > 2 ? !b.canBeJumped : true)){
            player.xpos = foo.gotoX;
            player.ypos = foo.gotoY;
        }
    }
    else{
        inkey = false;
        inworm = false;
    }
}
function respawnMath(){
    player.respawnTimer -= 1;
        if(player.respawnTimer < 0){
            player.alive = true;
            player.xpos = player.spawnX;
            player.ypos = player.spawnY;
            player.respawnTimer = timeToRespawn;
            player.zpos = 0;
            dx = 0; dy = 0; dz = 0;
        }
}
//} Function Declaration
function fixNegMovingBoxes(){
    for(var i = 0; i < boxes.length; i++){
        b = boxes[i];
        if(b.moveDistance*5 < 0){
            b.moveDistance = abs(b.moveDistance);
            if(b.moveVert){
                b.trueY -= b.moveDistance*5;
                b.hasTraveled = b.moveDistance*5;
            }
            else{
                b.trueX -= b.moveDistance*5;
                b.hasTraveled = b.moveDistance*5;
            }
        }
    }
}

//{
// Button class {
var Button = function(xpos,ypos,wdt,hgt,txt,tsz,col,stk,thk,cnr,aln,txtcol){
    this.xpos = xpos;
    this.ypos = ypos;
    this.width = wdt ? wdt : 100;
    this.height = hgt ? hgt : 50;
    this.color = col ? col : color(200,200,200);
    this.stroke = stk ? stk : color(0,0,0);
    this.thickness = thk ? thk + 0.00000001 : 1;
    this.text = txt ? txt : "Button";
    this.textsize = tsz ? tsz : 25;
    this.roundness = cnr ? cnr : 0;
    this.align = aln ? aln : 0;
    this.textcolor = txtcol ? txtcol : (stk ? stk : 0);
};
Button.prototype.draw = function() {
    fill(this.color);
    stroke(this.stroke);
    strokeWeight(this.thickness);
    rect(this.xpos*(1 + this.align*0.5), this.ypos*(1 + this.align*0.5), this.width, this.height, this.roundness);
    fill(this.textcolor);
    textAlign(CENTER,CENTER);
    textSize(this.textsize);
    text(this.text, this.xpos + this.width/2, this.ypos + this.height/2);
    textAlign(LEFT,CENTER);
};
Button.prototype.isOver = function() {
    return mouseX > this.xpos*(1 + this.align*0.5) && mouseY > this.ypos*(1 + this.align*0.5) && mouseX < this.xpos*(1 + this.align*0.5) + this.width && mouseY < this.ypos*(1 + this.align*0.5) + this.height;
};
Button.prototype.isPressed = function() {
    return this.isOver() && mouseIsPressed;
};
Button.prototype.isClicked = function() {
    return this.isOver() && mouseIsPressed && !mouseWasPressed;
};
Button.prototype.isReleased = function() {
    return this.isOver() && !mouseIsPressed && mouseWasPressed;
};
//}

var freecamButton = new Button(5, 35, 50, 20, "Free-Cam", 10);
var killButton = new Button(5, 5, 50, 20, "Kill", 10);
var immortalButton = new Button(5, 65, 50, 20, "Immortal", 10);
var mortalButton = new Button(5, 95, 50, 20, "Mortal", 10);
var noclipButton = new Button(5, 125, 50, 20, "No Clip", 10);
var hyperButton = new Button(5, 155, 50, 20, "Hyper", 10);
var debugMenuButton = new Button(5, height-25, 50, 20, "Debug", 10);
var gWallSwitch = new Button(70, 5, 50, 20, "Wall", 10);
var gPathSwitch = new Button(70, 35, 50, 20, "Platform", 10);
var gEraserSwitch = new Button(70, 65, 50, 20, "Eraser", 10);
var gVoidSwitch = new Button(70, 95, 50, 20, "Void", 10);
var gHurdleSwitch = new Button(70, 125, 50, 20, "Hurdle", 10);
g = Path;
var age = 0; var citers = 0;
draw = function() {
    if(victory){
        background(240);
        
        for(var i = -1; i < ceil(width/50); i+=2){
            for(var j = -1; j < ceil(height/50); j++){
                fill(230);
                rect(((i + j%2)*50), j*50, 50, 50);
                rect(((i + j%2)*50) + 60, j*50 + 10 , 30, 30);
                fill(240);
                rect(((i + j%2)*50) + 10, j*50 + 10, 50, 50);
            }
        }
        
        fill(0);
        noStroke();
        textSize(50);
        textAlign(CENTER,CENTER);
        text("YOU WON!", width/2, height/5);
        text(floor(time/1000/60)+":"+(floor(time/1000%60) < 10 ? "0" : "")+floor(time/1000%60)+":"+floor(time%1000), width/2, height*4/5);
        fill(255, 0, 0);
        text(deaths + " deaths", width/2, height/2);
        textSize(30);
        fill(0);
        text("with", width/2, height/2.75);
        text("in", width/2, height/1.55);
    }
    else{
        ctime = millis();
        background(255);

        fill(0,0,0,5);
        noStroke();
        for(var i = -2; i < ceil(width/50 + 1); i+=2){
            for(var j = -2; j < ceil(height/50 + 3); j++){
                rect(((i + j%2)*50) - player.xpos%100, j*50 - player.ypos%100, 50, 50);
            }
        }
        fixNegMovingBoxes();
        age += 1;
        frames += 1;
        fill(0);
        drawGame();
        if(player.alive){
            // Checking important things before anything happens
            specialCollision();
            
            // Keyboard control before to prevent rubber-banding
            keyboardControl();
            
            // "iters" used to break
            iters = 0;
            citers = 0;
            while(checkCollisions().collided && player.alive){
                elasticPower.x = 0;
                elasticPower.y = 0;
                iters += 1;
                player.xpos -= xmove;
                if(checkCollisions().collided){
                    player.ypos -= ymove;
                    player.xpos += xmove;
                    citers++;
                }
                if(iters > 1){
                    if(citers > 1 && !checkCollisions().wasJumpable && squish_does_kill){
                        killPlayer();
                    }
                    break;
                }
            } pdz = dz;
            
            movementMath();
        }
        else{
            respawnMath();
        }
        inkeyp = inkey;
        inwormp = inworm;
        ptime = ctime;
    
        if(isOnMenu){
            killButton.draw();
            freecamButton.draw();
            gWallSwitch.draw();
            gPathSwitch.draw();
            gEraserSwitch.draw();
            gVoidSwitch.draw();
            gHurdleSwitch.draw();
            mortalButton.draw();
            immortalButton.draw();
            noclipButton.draw();
            hyperButton.draw();
            if(killButton.isReleased()){
                killPlayer();
            }
            else if(freecamButton.isReleased()){
                if(freecamMode){
                    freecamMode = false;
                    player.xpos = camX - width/2;
                    player.ypos = camY - height/2;
                    xmove = 0;
                    ymove = 0;
                    dx = 0;
                    dy = 0;
                    speed = 1.1;
                }
                else{
                    freecamMode = true;
                    camX = player.xpos + width/2;
                    camY = player.ypos + height/2;
                    speed = 3;
                }
            }
            else if(gWallSwitch.isReleased()){
                gName = "Wall";
                g = Wall;
            }
            else if(gVoidSwitch.isReleased()){
                gName = "Void";
                g = Void;
            }
            else if(gHurdleSwitch.isReleased()){
                gName = "Hurdle";
                g = Hurdle;
            }
            else if(gEraserSwitch.isReleased()){
                gName = "Eraser";
                g = Eraser;
            }
            else if(gPathSwitch.isReleased()){
                gName = "Path";
                g = Path;
            }
            else if(mortalButton.isReleased()){
                canDie = true;
            }
            else if(immortalButton.isReleased()){
                canDie = false;
            }
            else if(noclipButton.isReleased()){
                noclip = !noclip;
            }
            else if(hyperButton.isReleased()){
                hyper = !hyper;
            }
        }
        if(debugMode){
            debugMenuButton.draw();
            if(debugMenuButton.isReleased()){
                isOnMenu = !isOnMenu;
            }
        }
        YouNeedToRunThisEachFrameItMakesTheInputWork();
    }
};
//}
//}
function mouseReleased(){
    mouseIsPressed = false;
    if(mouseButton === RIGHT){
        showText = !showText;
    }
}
function setGamerule(rule, value){
    if(rule === "Floor Kills"){
        if(value){
            Void(-1000000,-1000000,2000000,2000000);
        }
    }
    else if(rule === "Player Speed"){
        speed = value;
    }
}

function ToElastic(power){
    b = boxes[boxes.length - 1];
    b.isElastic = true;
    b.power = power;
}

function ToInvisible(){
    b = boxes[boxes.length - 1];
    b.isInvisible = true;
}

function ToMoving(mT,mD,mV){
    b = boxes[boxes.length - 1];
    b.moveSpeed = mT;
    b.moveDistance = mD;
    b.hasTraveled = 0;
    b.dir = 1;
    b.doesMove = true;
    b.trueX = b.xpos;
    b.trueY = b.ypos;
    b.moveVert = mV;
}

function ToMoving2(xSpeed, ySpeed, travelTime){
    b = boxes[boxes.length - 1];
    b.xSpeed = xSpeed;
    b.ySpeed = ySpeed;
    b.travelTime = travelTime;
    b.dir = 1;
    b.doesMove = true;
    b.advMoving = true;
}

function ToMoving3(xDistance, yDistance, travelTime){
    b = boxes[boxes.length - 1];
    b.xSpeed = xDistance/travelTime;
    b.ySpeed = yDistance/travelTime;
    b.travelTime = travelTime;
    b.doesMove = true;
    b.advMoving = true;
    b.trueX = b.xpos - xDistance;
    b.trueY = b.ypos - yDistance;
}

function ToFlickering(existingTime, missingTime){
    b = boxes[boxes.length - 1];
    b.flickers = true;
    b.existingTime = existingTime;
    b.missingTime = missingTime;
}

function ToCrumbling(crumbleTime){
    b = boxes[boxes.length - 1];
    b.crumbles = true;
    b.timer = 0;
    b.wasSteppedOn = false;
    b.crumbleTime = crumbleTime;
    b.crumbleSpeedX = b.width/crumbleTime;
    b.crumbleSpeedY = b.height/crumbleTime;
    b.maxWidth = b.width;
    b.maxHeight = b.height;
    b.trueX = b.xpos;
    b.trueY = b.ypos;
}

function ToActive(){
    b = boxes[boxes.length - 1];
    if(b.isKey){
        unlock(b.keycode);
    }
    else{
        println("ToActive() should be used after the creation of a key to start it activated.");
    }
}

function ActiveKey(keycode,x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 30, height:h ? h*5 : 30, color:c ? c : COLOR.GOLD, coll:false, kills:false, keycode:keycode, isKey:true, isLock:false});
    ToActive();
}

function ToForced(){
    b = boxes[boxes.length - 1];
    b.canBeJumped = false;
}

function ToJumpable(){
    b = boxes[boxes.length - 1];
    b.canBeJumped = true;
}

function Room(func,x,y,w,h,t,b,c){
    t = t ? t : 5;
    b = b ? b : 0;
    
    // Top and left wall
    func(x,y,w,t);
    func(x,y,t,h);
    func(x,y + h - t,w, t);
    func(x + w - t,y,t,h);
    
    // Corners
    func(x-b,y-b,t+2*b,t+2*b);
    func(x-b + w - t,y-b,t+2*b,t+2*b);
    func(x-b,y-b + h - t,t+2*b,t+2*b);
    func(x-b + w - t,y-b + h - t,t+2*b,t+2*b);
}

//}
