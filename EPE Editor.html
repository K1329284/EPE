<!DOCTYPE html>
<html> 
  <head>
    <title>EPE Editor</title> 
  </head>
  <body>
	<!--This draws the canvas on the webpage -->
    <canvas id="mycanvas"></canvas> 
  </body>
 
  <!-- Include the processing.js library -->
  <!-- See https://khanacademy.zendesk.com/hc/en-us/articles/202260404-What-parts-of-ProcessingJS-does-Khan-Academy-support- for differences -->
  <script src="https://cdn.jsdelivr.net/processing.js/1.4.8/processing.min.js"></script> 
  <script>
  var programCode = function(processingInstance) {
    with (processingInstance) {
      size(600, 400); 
      frameRate(60);
        
      // Paste code from Khan Academy here:
      // Game Rules {

// Name your game and put here, and how long its there.
var titleText = ""; var titleTime = 0;
var player_starting_x_position = 0;
var player_starting_y_position = 0;
var print_lag_spikes = false;
var player_walking_speed = 1;
var gravity_strength = 1;
var debugMode = true;
var show_timer = false;
var show_deaths = false;
var show_performance = true;
var speed_is_limited = false;
var final_script = "";

// Should the player die when squished by a moving wall?
// If false it pushes the player inside the wall which may cause problems.
var squish_does_kill = true;
// Set this to false when you want the players to use trial and error to figure things out or be given what links to.
var do_draw_linking_codes = true;

//}

// Close this {
frameRate(60);
var hyper = false;
var canDie = true;
var noclip = false;
var victory = false;
var epeFileMode = true;
var g = function(){};
var gName = "Path";
var arrow_head_size = 700;
var isOnMenu = false;
var ctime = millis();
var ptime = millis();
var start = millis();
var nothing, nil, empty, undef, noth, None, none;
var NOTHING, NIL, EMPTY, UNDEF, NOTHING, NONE, UNDEFINED;
var freecamMode = false;
var no = false, NO = false, yes = true, YES = true;
var showText = true;
var lastKeycode = "";
var inworm = false;
var inwormp = false;
var inkey = false;
var inkeyp = false;
var elasticPower = {x:0, y:0};
var selectPos1 = {xpos:0, ypos:0};
var selectPos2 = {xpos:0, ypos:0};
var mouseCurrentlyPressed = false;
var mouseIsPressed = false;
var mouseWasPressed = false;
var COLOR = {
    WALL : color(100),
    STONE : color(100),
    
    ERASER : color(255, 166, 0),
    LAVA : color(255, 166, 0),
    
    HOLE : color(87, 58, 9),
    DIRT : color(87, 58, 9),
    
    VOID : color(-100,-100,-100),
    
    CHECKPOINT : color(117, 235, 106),
    
    MUD : color(107, 87, 52),
    
    ICE : color(135, 232, 227),
    
    BOOSTER : color(224, 224, 97),
    
    TRAMPOLINE : color(164, 70, 214),
    
    TELEPORTER : color(56, 235, 235),
    DIAMOND : color(56, 235, 235),
    
    SULFUR : color(73, 74, 39),
    CONVEYOR : color(73, 74, 39),
    
    LOCKED_PLATFORM : color(194),
    SILVER : color(194),
    
    GOLD : color(255, 213, 0),
    KEY : color(255, 213, 0),
    
    LOCKED_WALL : color(80),
    BASALT : color(80),
    
    LOCKED_ERASER : color(219, 69, 0),
    MAGMA : color(219, 69, 0),
    
    WORMHOLE : color(83, 0, 125),
    OBSIDIAN : color(83, 0, 125),
    
    FAINT : color(128,128,128,20),
    
    TELEPORTER_TO : color(0, 160, 255),
    OCEAN : color(0, 160, 255),
    
    WIN : color(255,240,200),
    AETHER : color(255,240,200),
    
    BLACK : color(0),
    GRAY : color(128),
    WHITE : color(255),
    
    RED : color(255, 0, 0),
    ORANGE : color(255, 128, 0),
    YELLOW : color(255, 255, 0),
    CHART : color(180, 255, 0),
    GREEN : color(0, 255, 0),
    JADE : color(0, 255, 160),
    CYAN : color(0, 255, 255),
    AZURE : color(0, 160, 255),
    BLUE : color(0, 0, 255),
    PURPLE : color(140, 0, 255),
    MAGENTA : color(255, 0, 255),
    ROSE : color(255, 0, 128),
    
    PINK : color(255, 128, 128),
    TAN : color(225, 200, 150),
    BROWN : color(128, 64, 32),
};
//{


// Chapter One Record: 2:14:500

//{
var keys = [], pkeys = [], pressed = false, released = false;

var W = 87, A = 65, S = 83, D = 68, Q = 81, E = 69, Z = 90, X = 86, C = 67, R = 82, F = 70, V = 86, T = 84, Y = 89, U = 85, I = 73, O = 79, P = 80, G = 71, H = 72, J = 74, K = 75, L = 76, B = 66, M = 78, N = 77, SPACE = 32, OPEN_BRACKET = 219, CLOSED_BRACKET = 221;

for(var i = 0; i < 256; i++){
    keys.push(false);
}

function isDown(KEY){
    return keys[KEY];
}

function wasPressed(KEY){
    return keys[KEY] && !pkeys[KEY];
}

function wasReleased(KEY){
    return !keys[KEY] && pkeys[KEY];
}

function YouNeedToRunThisEachFrameItMakesTheInputWork(){
    if(pressed){
        pressed = false;
    }
    
    if(released){
        released = false;
    }
    
    pkeys = [];
    
    for(var i = 0; i < 256; i++){
        pkeys[i] = keys[i];
    }
    
    mouseWasPressed = mouseIsPressed;
}

mouseClicked = function(){
    mouseIsPressed = true;
};

var x1,x2,y1,y2;
keyPressed = function(){
    keys[keyCode] = true;
    pressed = keyCode;
};
keyReleased = function(){
    keys[keyCode] = false;
    released = keyCode;
    
    if(keyCode === CONTROL){
        println("(" + (x1-width)/5 + "," + (y1-height)/5 + "," + (x2-x1)/5 + "," + (y2-y1)/5 + ")" + (epeFileMode ? "" : ";"));
    }
    else if(keyCode === ALT){
        if(!epeFileMode){
            println(gName + "(" + (x1-width)/5 + "," + (y1-height)/5 + "," + (x2-x1)/5 + "," + (y2-y1)/5 + ");");
            if(debugMode){
                g((x1-width)/5, (y1-height)/5, (x2-x1)/5, (y2-y1)/5);
            }
        }
        else{
            final_script += gName.toUpperCase() + " (" + (x1-width)/5 + " " + (y1-height)/5 + " " + (x2-x1)/5 + " " + (y2-y1)/5 + ")\n";
            if(debugMode){
                g((x1-width)/5, (y1-height)/5, (x2-x1)/5, (y2-y1)/5);
            }
        }
    }
};
//} Evan\'s Toolkit
//{
var timeToRespawn = 30;
var pS = 30; // Player size (only visual)
var speed = 1.1*player_walking_speed; // Player speed
var G = 0.1*gravity_strength; // Gravity
//} Gamerules
//{
//{
var boxes = [];
var floors = [];
var textboxes = [];
var foreground = [];
var time;
var frames = 0;
var millistart = millis();
var player = {xpos:player_starting_x_position, ypos:player_starting_y_position, zpos:0, vel:0, alive:true, respawnTimer:timeToRespawn, spawnX:  player_starting_x_position, spawnY:  player_starting_y_position, spawnID: -1};
var oldplayer = {xpos:0, ypos:0};
var justLanded = 0;
var buffer = -5;
var deaths = 0;
var index;
var dx = 0, dy = 0, dz = 0, colli;
var b; var newColor;
//} Variable Declaration

//{
var notiTime = 3000; var notiText = "Hi there!";
function setNotification(noti){
    notiText = noti;
    notiTime = 1000;
}
function drawNotification(){
    notiTime -= 5;
    textSize(20);
    textAlign(LEFT, TOP);
    fill(255, 255, 255, notiTime);
    for(var i = -1; i <= 1; i++){
        for(var j = -1; j <= 2; j++){
            text(notiText, 5+i, 0+j);
        }
    }
    
    fill(0, 0, 0, notiTime);
    text(notiText, 5, 0);
}
//} Notifications

//{

function setTitle(noti){
    titleText = noti;
    titleTime = 1500;
}
function drawTitle(){
    titleTime -= 5;
    textSize(30);
    textAlign(CENTER, CENTER);
    fill(0,0,0,titleTime);
    noStroke();
    rect(0,0,width,height);
    fill(255, 255, 255, titleTime);
    text(titleText, width/2, height/2);
}
//}

function unlock(keycode){
    for(var i = 0; i < boxes.length; i++){
        b = boxes[i];
        if(b.isLock && b.keycode === keycode){
            if(b.isLPlat){
                b.vanished = false;
            }
            else{
                b.canBeJumped = true;
                b.coll = false;
            }
        }
    }
}
function relock(keycode){
    for(var i = 0; i < boxes.length; i++){
        b = boxes[i];
        if(b.isLock && b.keycode === keycode){
            if(b.isLPlat){
                b.vanished = true;
            }
            else{
                b.canBeJumped = false;
                b.coll = true;
            }
        }
    }
}

//} Starting Variables
//{
function Textbox(x,y,message,ts,c){
    textboxes.push({xpos:x, ypos:y, message:message, textsize:ts ? ts : 30, color:c ? c : COLOR.BLACK});
}
function Box(x,y,w,h,col,coll,jumpable,deadly,message,isACheckpoint){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:jumpable, width:w, height:h, color:col, coll:coll, kills:deadly, isCheckpoint:isACheckpoint, message:message});
}
function Wall(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w*5, height:h*5, color:c ? c : COLOR.WALL, coll:true, kills:false, isCheckpoint:false});
}
function Platform(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w*5, height:h*5, color:c ? c : COLOR.WALL, coll:false, kills:false, isCheckpoint:false});
}
function Hurdle(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w*5, height:h*5, color:c ? c : COLOR.WALL, coll:true, kills:false, isCheckpoint:false});
}
function Path(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w*5, height:h*5, color:c ? c : COLOR.WALL, coll:false, kills:false, isCheckpoint:false});
}
function Eraser(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w*5, height:h*5, color:c ? c : COLOR.LAVA, coll:true, kills:true, isCheckpoint:false});
}
function Hole(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w*5, height:h*5, color:c ? c : COLOR.HOLE, coll:false, kills:true, isCheckpoint:false});
}
function Void(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w*5, height:h*5, color:c ? c : COLOR.VOID, coll:false, kills:true, isCheckpoint:false});
}
function Checkpoint(x,y,m,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 80, height:h ? h*5 : 80, color:c ? c : COLOR.CHECKPOINT, coll:false, kills:false, isCheckpoint:true, message:m, textTrigger:false});
}
function ForcedCheckpoint(x,y,m,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 80, height:h ? h*5 : 80, color:c ? c : COLOR.CHECKPOINT, coll:false, kills:false, isCheckpoint:true, message:m, textTrigger:false});
}
function Mud(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w*5, height:h*5, color:c ? c : COLOR.MUD, coll:false, kills:false, isCheckpoint:false, slows:true});
}
function ForcedMud(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w*5, height:h*5, color:c ? c : COLOR.MUD, coll:false, kills:false, isCheckpoint:false, slows:true});
}
function Ice(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w*5, height:h*5, color:c ? c : COLOR.ICE, coll:false, kills:false, isCheckpoint:false, ice:true});
}
function ForcedIce(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w*5, height:h*5, color:c ? c : COLOR.ICE, coll:false, kills:false, isCheckpoint:false, ice:true});
}
function Booster(x,y,w,h,boost,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w*5, height:h*5, color:c ? c : COLOR.BOOSTER, coll:false, kills:false, isCheckpoint:false, boosts:true,boostPower:(boost ? boost : 0.1)});
}
function ForcedBooster(x,y,w,h,boost,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w*5, height:h*5, color:c ? c : COLOR.BOOSTER, coll:false, kills:false, isCheckpoint:false, boosts:true,boostPower:(boost ? boost : 0.1)});
}
function TeleporterIn(x,y,tc,w,h,c,i){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TELEPORTER, coll:false, kills:false, isCheckpoint:false, slows:false, tpc:tc, tpDir:"in", isInvisible:i ? i : false});
}
function TeleporterOut(x,y,tc,w,h,c,i){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TELEPORTER, coll:false, kills:false, isCheckpoint:false, slows:false, tpc:tc, tpDir:"out", isInvisible:i ? i : false});
}
function TeleporterOutA(x,y,tc,w,h,c,i){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TELEPORTER, coll:false, kills:false, isCheckpoint:false, slows:false, tpc:tc, tpDir:"out", isExact:true, isInvisible:i ? i : false});}
function TeleporterInForced(x,y,tc,w,h,c,i){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TELEPORTER, coll:false, kills:false, isCheckpoint:false, slows:false, tpc:tc, tpDir:"in", isInvisible:i ? i : false});
}
function Trampoline(x,y,w,h,jm,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TRAMPOLINE, coll:false, kills:false, slows:false, isTrampoline:true, jumpFactor:jm ? jm : 1});
}
function Key(keycode,x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 30, height:h ? h*5 : 30, color:c ? c : COLOR.GOLD, coll:false, kills:false, keycode:keycode, isKey:true, isLock:false});
}
function LockedWall(keycode,x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.BASALT, coll:true, kills:false, keycode:keycode, isKey:false, isLock:true});
}
function LockedEraser(keycode,x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.MAGMA, coll:false, kills:true, keycode:keycode, isKey:false, isLock:true});
}
function LockedPlatform(keycode,x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.SILVER, coll:false, kills:false, keycode:keycode, isKey:false, isLock:true, vanished:true, isLPlat:true});
}
function TeleporterTo(x,y,w,h,nx,ny,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.OCEAN, coll:false, kills:false, gotoX : round(nx*5), gotoY : round(ny*5), isTT: true});
}
function ForcedTeleporterTo(x,y,w,h,nx,ny,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.OCEAN, coll:false, kills:false, gotoX : round(nx*5), gotoY : round(ny*5), isTT: true});
}
function Wormhole(x,y,whc,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.OBSIDIAN, coll:false, kills:false, wormholeCode:whc});
}
function ForcedWormhole(x,y,whc,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.OBSIDIAN, coll:false, kills:false, wormholeCode:whc});
}
function ElasticWall(x,y,w,h,power,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.PINK, coll:false, kills:false, isElastic:true, power: power ? power : 2});
}
function Conveyor(x,y,w,h,xspd,yspd,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.SULFUR, coll:false, kills:false, isConveyor:true, xConv:xspd, yConv:yspd});
}
function ForcedConveyor(x,y,w,h,xspd,yspd,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.SULFUR, coll:false, kills:false, isConveyor:true, xConv:xspd, yConv:yspd});
}

function Template(x,y,w,h){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:COLOR.FAINT, coll:false, kills:false});
}

function MovingBox(x,y,w,h,col,coll,jumpable,deadly,message,isACheckpoint,moveSpeed,moveDistance,moveVert,slows,ice,boosts,boost){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:jumpable, width:w*5, height:h*5, color:col, coll:coll, kills:deadly, isCheckpoint:isACheckpoint, message:message, moveSpeed:moveSpeed, moveDistance:moveDistance,slows:slows,hasTraveled:0,dir:1,doesMove:true,trueX:x*5,trueY:y*5,moveVert:moveVert,boosts:(boosts ? true : false),boostPower:(boost ? boost : 0.1),ice:ice});
}

//{

function MovingWall(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.WALL,
    true/*collides*/,
    false/*jumpable*/,
    false/*kills*/,
    undefined/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV
    );
}
function MovingPlatform(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.WALL,
    false/*collides*/,
    false/*jumpable*/,
    false/*kills*/,
    undefined/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV
    );
}
function MovingPath(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.WALL,
    false/*collides*/,
    true/*jumpable*/,
    false/*kills*/,
    undefined/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV
    );
}
function MovingHurdle(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.WALL,
    true/*collides*/,
    true/*jumpable*/,
    false/*kills*/,
    undefined/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV
    );
}
function MovingEraser(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.LAVA,
    true/*collides*/,
    false/*jumpable*/,
    true/*kills*/,
    undefined/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV
    );
}
function MovingHole(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.HOLE,
    true/*collides*/,
    true/*jumpable*/,
    true/*kills*/,
    undefined/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV
    );
}
function MovingVoid(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.VOID,
    true/*collides*/,
    true/*jumpable*/,
    true/*kills*/,
    undefined/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV
    );
}
function MovingCheckpoint(x,y,m,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.CHECKPOINT,
    false/*collides*/,
    true/*jumpable*/,
    false/*kills*/,
    m/*message*/,
    true/*isCheckpoint*/,
    mT,
    mD,mV
    );
}
function MovingForcedCheckpoint(x,y,m,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.CHECKPOINT,
    false/*collides*/,
    false/*jumpable*/,
    false/*kills*/,
    m/*message*/,
    true/*isCheckpoint*/,
    mT,
    mD,mV
    );
}
function MovingMud(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.MUD,
    false/*collides*/,
    true/*jumpable*/,
    false/*kills*/,
    false/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV,
    true/*slows*/
    );
}
function MovingForcedMud(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.MUD,
    false/*collides*/,
    false/*jumpable*/,
    false/*kills*/,
    false/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV,
    true/*slows*/
    );
}
function MovingIce(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.ICE,
    false/*collides*/,
    true/*jumpable*/,
    false/*kills*/,
    false/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV,
    false,/*slows*/
    true/*ice*/
    );
}
function MovingForcedIce(x,y,w,h,mT,mD,mV,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.ICE,
    false/*collides*/,
    false/*jumpable*/,
    false/*kills*/,
    false/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV,
    false,/*slows*/
    true/*ice*/
    );
}
function MovingBooster(x,y,w,h,mT,mD,mV,bp,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.BOOSTER,
    false/*collides*/,
    true/*jumpable*/,
    false/*kills*/,
    false/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV,
    false,/*slows*/
    false,/*ice*/
    true,/*boosts*/
    bp/*boost power in %*/
    );
}
function MovingForcedBooster(x,y,w,h,mT,mD,mV,bp,c){
    MovingBox(x,y,w,h,
    c ? c : COLOR.BOOSTER,
    false/*collides*/,
    false/*jumpable*/,
    false/*kills*/,
    false/*message*/,
    false/*isCheckpoint*/,
    mT,
    mD,mV,
    false,/*slows*/
    false,/*ice*/
    true,/*boosts*/
    bp/*boost power in %*/
    );
}
function MovingTeleporterIn(x,y,tc,w,h,mT,mD,mV,c,i){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TELEPORTER, coll:false, kills:false, isCheckpoint:false, slows:false, tpc:tc, tpDir:"in", isInvisible:i ? i : false, moveSpeed:mT, moveDistance:mD,hasTraveled:0,dir:1,doesMove:true,trueX:x*5,trueY:y*5,moveVert:mV});
}
function MovingTeleporterOut(x,y,tc,w,h,mT,mD,mV,c,i){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TELEPORTER, coll:false, kills:false, isCheckpoint:false, slows:false, tpc:tc, tpDir:"out", isInvisible:i ? i : false, moveSpeed:mT, moveDistance:mD,hasTraveled:0,dir:1,doesMove:true,trueX:x*5,trueY:y*5,moveVert:mV});
}
function MovingTeleporterOutA(x,y,tc,w,h,mT,mD,mV,c,i){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TELEPORTER, coll:false, kills:false, isCheckpoint:false, slows:false, tpc:tc, tpDir:"out", isExact:true, isInvisible:i ? i : false, moveSpeed:mT, moveDistance:mD,hasTraveled:0,dir:1,doesMove:true,trueX:x*5,trueY:y*5,moveVert:mV});}
function MovingTeleporterInForced(x,y,tc,w,h,mT,mD,mV,c,i){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TELEPORTER, coll:false, kills:false, isCheckpoint:false, slows:false, tpc:tc, tpDir:"in", isInvisible:i ? i : false, moveSpeed:mT, moveDistance:mD,hasTraveled:0,dir:1,doesMove:true,trueX:x*5,trueY:y*5,moveVert:mV});
}
function MovingTrampoline(x,y,w,h,mT,mD,mV,jm,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 50, height:h ? h*5 : 50, color:c ? c : COLOR.TRAMPOLINE, coll:false, kills:false, slows:false, isTrampoline:true, jumpFactor:jm ? jm : 1, moveSpeed:mT, moveDistance:mD,hasTraveled:0,dir:1,doesMove:true,trueX:x*5,trueY:y*5,moveVert:mV});
}
function MovingKey(keycode,x,y,w,h,mT,mD,mV,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 30, height:h ? h*5 : 30, color:c ? c : COLOR.GOLD, coll:false, kills:false, keycode:keycode, isKey:true, isLock:false, moveSpeed:mT, moveDistance:mD,hasTraveled:0,dir:1,doesMove:true,trueX:x*5,trueY:y*5,moveVert:mV});
}
function Win(x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 30, height:h ? h*5 : 30, color:c ? c : COLOR.AETHER, coll:false, kills:false, isWin:true});
}
//} Every box creator

//{
function TextTrigger(x,y,m,w,h){
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:true, width:w ? w*5 : 80, height:h ? h*5 : 80, color:color(255, 255, 255,0), coll:false, kills:false, isCheckpoint:false, message:m, isTextTrigger:true});
}
//} Triggers

//{
function Floor(x,y,w,h,c){
    floors.push({xpos:x*5, ypos:y*5, width:w*5, height:h*5, color:c ? c : COLOR.SILVER});
}
function Fog(){
    
}
//} Floors

//} Object Creators




//{
var flickerLifetime, progress;
function flickerCurrentlyExists(boxToCheck){
    flickerLifetime = boxToCheck.existingTime + boxToCheck.missingTime;
    progress = frames % flickerLifetime;
    
    return progress < boxToCheck.existingTime;
}
var xmove, ymove, zmove, iters, pdz, foo, move, xOffset, yOffset, shrinkage; var cx1, cy1, cx2, cy2;
xmove = 0;
ymove = 0;
function drawBox(i){
    b = boxes[i];
    if((b.xpos < player.xpos + width/2 && b.xpos + b.width > player.xpos - width/2 && b.ypos < player.ypos + height/2 && b.ypos + b.height > player.ypos - height/2) || freecamMode){ // If box is close enough to matter
    if(!b.isInvisible && (!b.flickers || flickerCurrentlyExists(b))){
        if(!b.vanished){
            fill(b.color);
            strokeWeight(5);
            if(!b.isTextTrigger){
                stroke(lerpColor(b.color,color(255*(b.canBeJumped ? 1 : 0)),0.3));
            }
            else{
                noStroke();
                if(debugMode){
                    stroke(255,255,255);
                    strokeWeight(5);
                }
            }
        }
        else{
            fill(COLOR.FAINT);
            stroke(COLOR.FAINT);
            strokeWeight(5);
        }
        
        rect(b.xpos - player.xpos + width/2, b.ypos - player.ypos + height/2, b.width, b.height,5);
        
        
        if(do_draw_linking_codes && showText){
            textAlign(CENTER, CENTER);
            textSize(15);
            fill(0);
            if(b.keycode !== undefined){
                text(b.keycode, b.xpos - player.xpos + width/2 + b.width/2, b.ypos - player.ypos + height/2 + b.height/2);
            }
            else if(b.tpc !== undefined){
                text(b.tpc, b.xpos - player.xpos + width/2 + b.width/2, b.ypos - player.ypos + height/2 + b.height/2);
            }
            else if(b.wormholeCode !== undefined){
                text(b.wormholeCode, b.xpos - player.xpos + width/2 + b.width/2, b.ypos - player.ypos + height/2 + b.height/2);
            }
        }
        if(b.isConveyor){
            cx1 = b.xpos - player.xpos + width/2 + b.width/2;
            cy1 = b.ypos - player.ypos + height/2 + b.height/2;
            cx2 = cx1 + b.xConv*10;
            cy2 = cy1 + b.yConv*10;
            
            var angle = atan2(cy2 - cy1, cx2 - cx1); 
            
            strokeWeight(10);
            stroke(0, 0, 0);
            line(cx1, cy1, cx2, cy2);
            line(cx2, cy2, cx2 - 10*cos(angle + 45), cy2 - 10*sin(angle + 45));
            line(cx2, cy2, cx2 - 10*cos(angle - 45), cy2 - 10*sin(angle - 45));
            strokeWeight(5);
            stroke(255, 255, 255);
            line(cx1, cy1, cx2, cy2);
            line(cx2, cy2, cx2 - 10*cos(angle + 45), cy2 - 10*sin(angle + 45));
            line(cx2, cy2, cx2 - 10*cos(angle - 45), cy2 - 10*sin(angle - 45));
        }
    }
    }
    if(b.isTT){
        textSize(15);
        fill(0, 0, 0);
                text("(" + b.gotoX/5 + ", " + b.gotoY/5 + ")", b.xpos - player.xpos + width/2 + b.width/2, b.ypos - player.ypos + height/2 + b.height/2);
                text("(" + b.gotoX/5 + ", " + b.gotoY/5 + ")", b.gotoX - player.xpos + width/2 + b.width/2 - 50, b.gotoY - player.ypos + height/2 + b.height/2 - 50);
            }
}
var f;
function drawFloor(i){
    f = floors[i];
    fill(f.color);
    noStroke();
    rect(f.xpos - player.xpos + width/2, f.ypos - player.ypos + height/2, f.width, f.height);
}
var playerInside = false;
function checkCollision(i){
    b = boxes[i];
    
    playerInside = !noclip && (b.xpos+buffer < player.xpos && player.xpos < b.xpos + b.width-buffer &&
    b.ypos+buffer < player.ypos && player.ypos < b.ypos + b.height-buffer);
    
    return playerInside && !b.vanished && (!b.flickers || flickerCurrentlyExists(b));
}
function checkCollisions(){
    if(freecamMode){
        return {};
    }
    for(var i = boxes.length - 1; i >= 0 ; i--){
        if(checkCollision(i)){
            return {
                collided:b.coll && (player.zpos > 2 ? !b.canBeJumped : true),
                killed:b.kills && (player.zpos > 2 ? !b.canBeJumped : true), 
                checkpoint:b.isCheckpoint,
                wasJumpable:b.canBeJumped && b.coll && (player.zpos > 2 ? !b.canBeJumped : true) && (!b.flickers || flickerCurrentlyExists(b)),
                
                boxID:i,
                
                slows:!!b.slows && (player.zpos > 2 ? !b.canBeJumped : true),
                noFriction: b.ice && (player.zpos > 2 ? !b.canBeJumped : true),
                boosted: b.boosts && (player.zpos > 2 ? !b.canBeJumped : true),
                boostPower: b.boostPower*(player.zpos > 2 ? !b.canBeJumped : true),
                moved:!!b.doesMove && (player.zpos < 2) && (!b.flickers || flickerCurrentlyExists(b)),
                isWall:b.coll && !b.kills && !b.canBeJumped,
                movingVertical:!!b.moveVert,
                moveSpeed:b.moveSpeed,
                moveDirection:b.dir,
                advMoved:!!b.advMoving && (player.zpos < 2) && (!b.flickers || flickerCurrentlyExists(b)),
            };
        }
        
    }
    return {collided:false, killed:false, checkpoint:false};
}

/*
Here I would like to define two term.
Pre-ironing collision and post-ironing collision.

"Ironing" here is the process of returning the collision object with all the data shown above.

If something collides "pre-ironed" then it will have an object returned about it, but if it does not then it will not.

When jumping over an object the player still collides with it, but the "ironing" corrects this. This nuance allows for ToForced() objects to exists and not exist.

Although jumping is a "post-ironing" collision issue, a ToFlickering() object is actually "pre-ironed" out to prevent collision issues. (Which otherwise do happen)

One question you may have is "Why is everything not pre-ironed?" and there are two answers.
1. "Pre-ironing" calculations are done PER OBJECT so any addition could easily begin to slow down performance. Returning the top-most object where the player is even if they are not touching it is fine since the calculation for it can be done a single time during "post-ironing".
2. Getting the object below the player even when not touched allows the differentiation between Forced and not Forced objects.
*/

function unlock(keycode){
    for(var i = 0; i < boxes.length; i++){
        b = boxes[i];
        if(b.isLock && b.keycode === keycode){
            if(b.isLPlat){
                b.vanished = false;
            }
            else{
                b.canBeJumped = true;
                b.coll = false;
            }
        }
    }
}
function relock(keycode){
    for(var i = 0; i < boxes.length; i++){
        b = boxes[i];
        if(b.isLock && b.keycode === keycode){
            if(b.isLPlat){
                b.vanished = true;
            }
            else{
                b.canBeJumped = false;
                b.coll = true;
            }
        }
    }
}
var camX = width/2, camY = height/2;
function drawPlayer(){
    strokeWeight(5);
    fill(255*(canDie && !noclip), 255*(noclip), 255*(!canDie && !noclip), pow((255 - player.zpos)/255,1.5)*255 - 128*(freecamMode));
    stroke(168*(canDie && !noclip), 168*(noclip), 168*(!canDie && !noclip), pow((255 - player.zpos)/255,1.5)*255 - 128*(freecamMode));
    strokeWeight((5 + justLanded*5)*player.respawnTimer/timeToRespawn);
    if(!freecamMode){
        camX = lerp(camX, width/2 + xmove, 0.2);
        camY = lerp(camY, height/2 + ymove, 0.2);
        ellipse(camX, camY, (pS + player.zpos)*player.respawnTimer/timeToRespawn, (pS + player.zpos)*player.respawnTimer/timeToRespawn);
    }
    else{
        ellipse(camX - player.xpos, camY - player.ypos, (pS + player.zpos)*player.respawnTimer/timeToRespawn, (pS + player.zpos)*player.respawnTimer/timeToRespawn);
        ellipse(width/2, height/2, (pS + player.zpos)*player.respawnTimer/timeToRespawn, (pS + player.zpos)*player.respawnTimer/timeToRespawn);
    }
    
    justLanded -= 1;
    
    if(hyper){
        fill(0,0,0,0);
        stroke(255,100);
        strokeWeight(30);
        for(var i = 3; i < 5; i++){
            ellipse(camX, camY, i*30, i*30);
        }
    }
}
var next_color = color(255,0,0), current_color = color(255,0,0);
function displayTime(){
    stroke(1);
    strokeWeight(1);
    if(show_timer || show_deaths){
        fill(230, 230, 230);
        rect(width-61,0,60,4 + 10*(show_timer + show_deaths));
        fill(0, 0, 0);
        textSize(12);
        textAlign(CENTER, CENTER);
        time = millis() - millistart;
        if(show_timer){
            text(floor(time/1000/60)+":"+(floor(time/1000%60) < 10 ? "0" : "")+floor(time/1000%60)+":"+floor(time%1000), width-30, 8);
        }
        if(show_deaths){
            fill(200, 0, 0);
            text(deaths + " deaths", width-30, 18 - 10*!show_timer);
        }
    }
    
    // If drops below 15fps
    if(ctime - ptime > 66 && print_lag_spikes){
        println("Lag spike: " + round(ctime - ptime));
    }
    
    if(show_performance){
        next_color = color(pow((ctime - ptime)/17, 5)*255, 0, 0);
        current_color = lerpColor(current_color, next_color, 0.08);
        fill(current_color);
        rect(width - 21, 4*(show_timer || show_deaths) + 10*(show_timer + show_deaths), 20, 20);
    }
}

function drawTestBox(){
    x1 = min(selectPos1.xpos,selectPos2.xpos)*5;
    x2 = max(selectPos1.xpos,selectPos2.xpos)*5;
    y1 = min(selectPos1.ypos,selectPos2.ypos)*5;
    y2 = max(selectPos1.ypos,selectPos2.ypos)*5;
    
    stroke(255,0,0,100);
    fill(0,255,0,100);
    strokeWeight(5);
    rect(x1 - player.xpos - width/2,y1 - player.ypos - height/2,x2-x1,y2-y1,5);
}
var textbox; var progress; var oldX, oldY;
function drawGame(){
    for(var i = 0; i < floors.length; i++){
        drawFloor(i);
    }
    for(var i = 0; i < boxes.length; i++){
        b = boxes[i];
        if(b.crumbles){
            if(b.width > 0 && b.wasSteppedOn){
                b.xpos += b.crumbleSpeedX/2;
                b.ypos += b.crumbleSpeedY/2;
                b.width -= b.crumbleSpeedX;
                b.height -= b.crumbleSpeedY;
                if(b.width <= 0){
                    b.timer = b.crumbleTime;
                }
                b.width = constrain(b.width, 0, b.maxWidth);
                b.height = constrain(b.height, 0, b.maxHeight);
                if(b.width <= 0){
                    b.timer = b.crumbleTime*5;
                    b.isInvisible = true;
                }
            }
            else if(b.wasSteppedOn){
                b.timer -= 1;
                if(b.timer < 0){
                    b.width = b.maxWidth;
                    b.height = b.maxHeight;
                    b.xpos -= b.maxWidth/2;
                    b.ypos -= b.maxHeight/2;
                    b.timer = b.crumbleTime*5;
                    b.wasSteppedOn = false;
                    b.isInvisible = false;
            }
        }
        }
        if(b.doesMove){
            if(b.advMoving){
                progress = (millis() % (4*b.travelTime))/b.travelTime;    
                progress = (progress % 2 - 1) * (progress > 2 ? 1 : -1);
                b.dir = progress > 1 ? 1 : -1;
                
                oldX = b.xpos;
                oldY = b.ypos;
                
                b.xpos = b.trueX + progress*b.xSpeed*b.travelTime;
                b.ypos = b.trueY + progress*b.ySpeed*b.travelTime;
                
                b.xmoved = oldX - b.xpos;
                b.ymoved = oldY - b.ypos;
            }
            else{
                if(b.hasTraveled > b.moveDistance*5){
                    b.dir = -1;
                }
                if(b.hasTraveled < 0){
                    b.dir = 1;
                }
                b.hasTraveled += b.dir*b.moveSpeed;
                
                if(b.moveVert){
                    b.ypos = b.trueY + b.hasTraveled;
                }
                else{
                    b.xpos = b.trueX + b.hasTraveled;
                }
            }
        }
        drawBox(i);
    }
    drawPlayer();
    drawTestBox();
    drawNotification();
    drawTitle();
    
    if(showText){
        textAlign(CENTER, CENTER);
        for(var i = 0; i < textboxes.length; i++){
            textbox = textboxes[i];
            if((player.xpos < textbox.xpos*5 + width * player.xpos > textbox.xpos*5 - width) || freecamMode){
                fill(textbox.color);
                textSize(textbox.textsize);
                text(textbox.message, textbox.xpos*5 - player.xpos + width/2, textbox.ypos*5 - player.ypos + height/2);
            }
        }
    }
    displayTime();
}
function killPlayer(){
    if(canDie){
        player.alive = false;
        player.respawnTimer = timeToRespawn;
        dx = 0;
        dy = 0;
        dz = 0;
        elasticPower.x = 0;
        elasticPower.y = 0;
        deaths += 1;
    }
}
function mousePosToRealPos(){
    return {xpos:round((mouseX + player.xpos + width/2)/5), ypos:round((mouseY + player.ypos + height/2)/5)};
}

var colliBox;
function keyboardControl(){
    colli = checkCollisions();
    colliBox = boxes[colli.boxID];
    
    
    if(colli.moved || (colli.isWall && b.moveSpeed !== undefined)){ 
        if(colli.advMoved){
            player.xpos -= colliBox.xmoved;
            player.ypos -= colliBox.ymoved;
        }
        else if(colli.movingVertical){
            player.ypos += b.dir*b.moveSpeed*1;
        }
        else{
            player.xpos += b.dir*b.moveSpeed*1;
        }
        
        
    }
    
    if((isDown(SHIFT) || isDown(SPACE)) && player.zpos < 1){
        dz = 3;
    }
    if(isDown(LEFT) || isDown(A)){
        dx += -1 * (hyper ? 5 : 1);}
    if(isDown(RIGHT) || isDown(D)){
        dx += 1 * (hyper ? 5 : 1);}
    if(isDown(UP) || isDown(W)){
        dy += -1 * (hyper ? 5 : 1);}
    if(isDown(DOWN) || isDown(S)){
        dy += 1 * (hyper ? 5 : 1);}
    if(isDown(K)){
        killPlayer();}
    if(isDown(OPEN_BRACKET) || isDown(O)){
        selectPos1 = mousePosToRealPos();
    }
    if(isDown(CLOSED_BRACKET) || isDown(P)){
        selectPos2 = mousePosToRealPos();
    }
}
var colli;
var B;
function movementMath(){
    xmove = 0;
    ymove = 0;
    dx += elasticPower.x;
    dy += elasticPower.y;
    elasticPower.x *= 0.7;
    elasticPower.y *= 0.7;
    
    colli = checkCollisions();
    B = boxes[colli.boxID];
    
    if(B !== undefined && B.isTrampoline && (player.zpos < 1)){
        dz = 3*B.jumpFactor;
    }
    
    if(freecamMode){
        dx *= 0.9;
        dy *= 0.9;
    }
    else if(colli.noFriction){
        dy *= 0.97;
        dx *= 0.97;
    }
    else if(colli.slows){
        dy *= 0.4;
        dx *= 0.4;
    }
    else if(colli.boosted){
        dy *= 1 + colli.boostPower;
        dx *= 1 + colli.boostPower;
    }
    else{
        dy *= 0.8;
        dx *= 0.8;
    }
    
    if(!colli.wasJumpable){
        xmove = dx*speed;
        ymove = dy*speed;
        
        if(!freecamMode){
            if(!colli.boosted){
                if(speed_is_limited){
                    xmove = min(abs(xmove), min(6.25 + abs(elasticPower.x),50))*(xmove === 0 ? 0 : abs(xmove)/xmove);
                    ymove = min(abs(ymove), min(6.25 + abs(elasticPower.y),50))*(ymove === 0 ? 0 : abs(ymove)/ymove);
                }
            }
            else{
                if(speed_is_limited){
                    xmove = min(abs(xmove), width)*(xmove === 0 ? 0 : abs(xmove)/xmove);
                    ymove = min(abs(ymove), height)*(ymove === 0 ? 0 : abs(ymove)/ymove);
                }
            }
        }
        
        player.xpos += xmove;
        player.ypos += ymove;
    }
    dz -= G;
    
    player.zpos += dz;
    if(player.zpos < -1){
        player.dz = 0;
        player.zpos = 0;
    }
}
var m;
function specialCollision(){
    m = checkCollisions();
    foo = boxes[m.boxID];
    if(foo !== undefined){
        if(m.killed){
            killPlayer();
        }
        
        else if(foo.wormholeCode && (player.zpos > 2 ? !foo.canBeJumped : true)){
            inworm = true;
            if(!inwormp){
                for(var i = 0; i < boxes.length; i++){
                    b = boxes[i];
                    if(m.boxID !== i && b.wormholeCode === foo.wormholeCode){
                        xOffset = constrain(player.xpos - foo.xpos, 0, b.width);
                        yOffset = constrain(player.ypos - foo.ypos, 0, b.height);
                        player.xpos = b.xpos + xOffset;
                        player.ypos = b.ypos + yOffset; 
                    }
                }
            }
        }
        
        else if(foo.isCheckpoint && (player.zpos > 2 ? !foo.canBeJumped : true)){
            player.spawnX = foo.xpos + foo.width/2;
            player.spawnY = foo.ypos + foo.height/2;
            setNotification(foo.message+"");
        }
        
        else if(foo.isElastic){
            elasticPower.x -= dx*foo.power;
            elasticPower.y -= dy*foo.power;
        }
        
        else if(foo.isConveyor && (player.zpos > 2 ? !foo.canBeJumped : true)){
            dx += foo.xConv/5;
            dy += foo.yConv/5;
        }
        
        if(foo.isKey && !inkey){
            inkey = true;
            if(!foo.canBeJumped){
                unlock(foo.keycode);
                lastKeycode = foo.keycode;
                foo.canBeJumped = true;
            }
            else{
                relock(foo.keycode);
                lastKeycode = foo.keycode;
                foo.canBeJumped = false;
            }
        }
        else if(foo.isKey){
            
        }
        else{
            inkey = false;
        }
        
        if(foo.crumbles && (player.zpos > 2 ? !foo.canBeJumped : true)){
            b.wasSteppedOn = true;
        }
        
        if(foo.isTextTrigger){
            setNotification(foo.message+"");
            index = boxes.indexOf(foo);
            boxes.splice(index, 1);
        }
        else if(foo.isWin){
            victory = true;
        }
        if(foo.tpDir === "in" && foo.tpc !== 0 && (player.zpos > 2 ? !b.canBeJumped : true)){
            for(var i = 0; i < boxes.length; i++){
                if(boxes[i].tpc){
                    b = boxes[i];
                    if(b.tpDir==="out" && foo.tpc===b.tpc){
                        if(b.isExact){
                            xOffset = constrain(player.xpos - foo.xpos, 0, b.width);
                            yOffset = constrain(player.ypos - foo.ypos, 0, b.height);
                            player.xpos = b.xpos + xOffset;
                            player.ypos = b.ypos + yOffset; 
                        }
                        else{
                            player.xpos = b.xpos + b.width/2;
                            player.ypos = b.ypos + b.height/2;
                        }
                        break;
                    }
                }
                else{
                    continue;
                }
            }
        }
        else if(foo.isTT && (player.zpos > 2 ? !b.canBeJumped : true)){
            player.xpos = foo.gotoX;
            player.ypos = foo.gotoY;
        }
    }
    else{
        inkey = false;
        inworm = false;
    }
}
function respawnMath(){
    player.respawnTimer -= 1;
        if(player.respawnTimer < 0){
            player.alive = true;
            player.xpos = player.spawnX;
            player.ypos = player.spawnY;
            player.respawnTimer = timeToRespawn;
            player.zpos = 0;
            dx = 0; dy = 0; dz = 0;
        }
}
//} Function Declaration
function fixNegMovingBoxes(){
    for(var i = 0; i < boxes.length; i++){
        b = boxes[i];
        if(b.moveDistance*5 < 0){
            b.moveDistance = abs(b.moveDistance);
            if(b.moveVert){
                b.trueY -= b.moveDistance*5;
                b.hasTraveled = b.moveDistance*5;
            }
            else{
                b.trueX -= b.moveDistance*5;
                b.hasTraveled = b.moveDistance*5;
            }
        }
    }
}

//{
// Button class {
var Button = function(xpos,ypos,wdt,hgt,txt,tsz,col,stk,thk,cnr,aln,txtcol){
    this.xpos = xpos;
    this.ypos = ypos;
    this.width = wdt ? wdt : 100;
    this.height = hgt ? hgt : 50;
    this.color = col ? col : color(200,200,200);
    this.stroke = stk ? stk : color(0,0,0);
    this.thickness = thk ? thk + 0.00000001 : 1;
    this.text = txt ? txt : "Button";
    this.textsize = tsz ? tsz : 25;
    this.roundness = cnr ? cnr : 0;
    this.align = aln ? aln : 0;
    this.textcolor = txtcol ? txtcol : (stk ? stk : 0);
};
Button.prototype.draw = function() {
    fill(this.color);
    stroke(this.stroke);
    strokeWeight(this.thickness);
    rect(this.xpos*(1 + this.align*0.5), this.ypos*(1 + this.align*0.5), this.width, this.height, this.roundness);
    if(this.isOver()){
        fill(0, 0, 0, 32);
        rect(this.xpos*(1 + this.align*0.5), this.ypos*(1 + this.align*0.5), this.width, this.height, this.roundness);
    }
    fill(this.textcolor);
    textAlign(CENTER,CENTER);
    textSize(this.textsize);
    text(this.text, this.xpos + this.width/2, this.ypos + this.height/2);
    textAlign(LEFT,CENTER);
};
Button.prototype.isOver = function() {
    return mouseX > this.xpos*(1 + this.align*0.5) && mouseY > this.ypos*(1 + this.align*0.5) && mouseX < this.xpos*(1 + this.align*0.5) + this.width && mouseY < this.ypos*(1 + this.align*0.5) + this.height;
};
Button.prototype.isPressed = function() {
    return this.isOver() && mouseIsPressed;
};
Button.prototype.isClicked = function() {
    return this.isOver() && mouseIsPressed && !mouseWasPressed;
};
Button.prototype.isReleased = function() {
    return this.isOver() && !mouseIsPressed && mouseWasPressed;
};
//}

var freecamButton = new Button(5, 35, 50, 20, "Free-Cam", 10);
var killButton = new Button(5, 5, 50, 20, "Kill", 10);
var immortalButton = new Button(5, 65, 50, 20, "Immortal", 10);
var mortalButton = new Button(5, 95, 50, 20, "Mortal", 10);
var noclipButton = new Button(5, 125, 50, 20, "No Clip", 10);
var hyperButton = new Button(5, 155, 50, 20, "Hyper", 10);
var teleportButton = new Button(5, 185, 50, 20, "Put player", 10);
var debugMenuButton = new Button(5, height-25, 50, 20, "Debug", 10);
var gWallSwitch = new Button(70, 5, 50, 20, "Wall", 10);
var gPathSwitch = new Button(70, 35, 50, 20, "Platform", 10);
var gEraserSwitch = new Button(70, 65, 50, 20, "Eraser", 10);
var gVoidSwitch = new Button(70, 95, 50, 20, "Void", 10);
var gHurdleSwitch = new Button(70, 125, 50, 20, "Hurdle", 10);
var compileButton = new Button(70, 155, 50, 20, "Get Code", 10);
var gPlaceholderSwitch = new Button(135, 5, 50, 20, "Template", 10);
var deleteLastButton = new Button(200, 5, 50, 20, "Delete Last", 10);
var undoLastDeleteButton = new Button(200, 35, 50, 20, "Undo Del", 10);
g = Path;
var age = 0; var citers = 0; var previousDeletes = [];
draw = function() {
    if(victory){
        background(240);
        
        for(var i = -1; i < ceil(width/50); i+=2){
            for(var j = -1; j < ceil(height/50); j++){
                fill(230);
                rect(((i + j%2)*50), j*50, 50, 50);
                rect(((i + j%2)*50) + 60, j*50 + 10 , 30, 30);
                fill(240);
                rect(((i + j%2)*50) + 10, j*50 + 10, 50, 50);
            }
        }
        
        fill(0);
        noStroke();
        textSize(50);
        textAlign(CENTER,CENTER);
        text("YOU WON!", width/2, height/5);
        text(floor(time/1000/60)+":"+(floor(time/1000%60) < 10 ? "0" : "")+floor(time/1000%60)+":"+floor(time%1000), width/2, height*4/5);
        fill(255, 0, 0);
        text(deaths + " deaths", width/2, height/2);
        textSize(30);
        fill(0);
        text("with", width/2, height/2.75);
        text("in", width/2, height/1.55);
    }
    else{
        ctime = millis();
        background(255);
        fill(0,0,0,5);
        noStroke();
        for(var i = -2; i < ceil(width/50 + 1); i+=2){
            for(var j = -2; j < ceil(height/50 + 3); j++){
                rect(((i + j%2)*50) - player.xpos%100, j*50 - player.ypos%100, 50, 50);
            }
        }
        fixNegMovingBoxes();
        age += 1;
        frames += 1;
        fill(0);
        drawGame();
        if(player.alive){
            // Checking important things before anything happens
            specialCollision();
            
            // Keyboard control before to prevent rubber-banding
            keyboardControl();
            
            // "iters" used to break
            iters = 0;
            citers = 0;
            while(checkCollisions().collided && player.alive){
                elasticPower.x = 0;
                elasticPower.y = 0;
                iters += 1;
                player.xpos -= xmove;
                if(checkCollisions().collided){
                    player.ypos -= ymove;
                    player.xpos += xmove;
                    citers++;
                }
                if(iters > 1){
                    if(citers > 1 && !checkCollisions().wasJumpable && squish_does_kill){
                        killPlayer();
                    }
                    break;
                }
            } pdz = dz;
            
            movementMath();
        }
        else{
            respawnMath();
        }
        inkeyp = inkey;
        inwormp = inworm;
        ptime = ctime;
    
        if(isOnMenu){
            killButton.draw();
            freecamButton.draw();
            gWallSwitch.draw();
            gPathSwitch.draw();
            gEraserSwitch.draw();
            gVoidSwitch.draw();
            gHurdleSwitch.draw();
            mortalButton.draw();
            immortalButton.draw();
            noclipButton.draw();
            hyperButton.draw();
            compileButton.draw();
            teleportButton.draw();
            gPlaceholderSwitch.draw();
            deleteLastButton.draw();
            undoLastDeleteButton.draw();
            
            if(killButton.isReleased()){
                killPlayer();
            }
            else if(freecamButton.isReleased()){
                if(freecamMode){
                    freecamMode = false;
                    player.xpos = camX - width/2;
                    player.ypos = camY - height/2;
                    camX = width/2;
                    camY = height/2;
                    xmove = 0;
                    ymove = 0;
                    dx = 0;
                    dy = 0;
                    speed = 1.1;
                }
                else{
                    freecamMode = true;
                    camX = player.xpos + width/2;
                    camY = player.ypos + height/2;
                    speed = 3;
                }
            }
            else if(gWallSwitch.isReleased()){
                gName = "Wall";
                println("// Object type switched to: " + gName);
                g = Wall;
            }
            else if(gVoidSwitch.isReleased()){
                gName = "Void";
                println("// Object type switched to: " + gName);
                g = Void;
            }
            else if(gHurdleSwitch.isReleased()){
                gName = "Hurdle";
                println("// Object type switched to: " + gName);
                g = Hurdle;
            }
            else if(gEraserSwitch.isReleased()){
                gName = "Eraser";
                println("// Object type switched to: " + gName);
                g = Eraser;
            }
            else if(gPathSwitch.isReleased()){
                gName = "Path";
                println("// Object type switched to: " + gName);
                g = Path;
            }
            else if(gPlaceholderSwitch.isReleased()){
                gName = "{change this}";
                println("// Object type switched to: PLACEHOLDER");
                g = Template;
            }
            else if(mortalButton.isReleased()){
                canDie = true;
            }
            else if(immortalButton.isReleased()){
                canDie = false;
            }
            else if(noclipButton.isReleased()){
                noclip = !noclip;
            }
            else if(hyperButton.isReleased()){
                hyper = !hyper;
            }
            else if(compileButton.isReleased()){
                println(final_script);
            }
            else if(teleportButton.isReleased()){
                if(freecamMode){
                    freecamMode = false;
                    xmove = 0;
                    ymove = 0;
                    dx = 0;
                    dy = 0;
                    speed = 1.1;
                    camX = width/2;
                    camY = height/2;
                }
            }
            else if(deleteLastButton.isReleased()){
                // Removing the last box from the array and putting it in a variable to undo it later
                if(boxes.length > 0){
                    previousDeletes.push(boxes.pop());
                }
            }
            else if(undoLastDeleteButton.isReleased()){
                if(previousDeletes.length > 0){
                    boxes.push(previousDeletes.pop());
                }
            }
        }
        if(debugMode){
            debugMenuButton.draw();
            if(debugMenuButton.isReleased()){
                isOnMenu = !isOnMenu;
            }
        }
        YouNeedToRunThisEachFrameItMakesTheInputWork();
    }

    mouseIsPressed = false;
};
//}
//}
function mouseReleased(){
    if(mouseButton === RIGHT){
        showText = !showText;
    }
}
function setGamerule(rule, value){
    if(rule === "Floor Kills"){
        if(value){
            Void(-1000000,-1000000,2000000,2000000);
        }
    }
    else if(rule === "Player Speed"){
        speed = value;
    }
}

function ToElastic(power){
    b = boxes[boxes.length - 1];
    b.isElastic = true;
    b.power = power;
}

function ToInvisible(){
    b = boxes[boxes.length - 1];
    b.isInvisible = true;
}

function ToMoving(mT,mD,mV){
    b = boxes[boxes.length - 1];
    b.moveSpeed = mT;
    b.moveDistance = mD;
    b.hasTraveled = 0;
    b.dir = 1;
    b.doesMove = true;
    b.trueX = b.xpos;
    b.trueY = b.ypos;
    b.moveVert = mV;
}

function ToMoving2(xSpeed, ySpeed, travelTime){
    b = boxes[boxes.length - 1];
    b.xSpeed = xSpeed;
    b.ySpeed = ySpeed;
    b.travelTime = travelTime;
    b.dir = 1;
    b.doesMove = true;
    b.advMoving = true;
}

function ToMoving3(xDistance, yDistance, travelTime){
    b = boxes[boxes.length - 1];
    b.xSpeed = xDistance/travelTime;
    b.ySpeed = yDistance/travelTime;
    b.travelTime = travelTime;
    b.doesMove = true;
    b.advMoving = true;
    b.trueX = b.xpos - xDistance;
    b.trueY = b.ypos - yDistance;
}

function ToFlickering(existingTime, missingTime){
    b = boxes[boxes.length - 1];
    b.flickers = true;
    b.existingTime = existingTime;
    b.missingTime = missingTime;
}

function ToCrumbling(crumbleTime){
    b = boxes[boxes.length - 1];
    b.crumbles = true;
    b.timer = 0;
    b.wasSteppedOn = false;
    b.crumbleTime = crumbleTime;
    b.crumbleSpeedX = b.width/crumbleTime;
    b.crumbleSpeedY = b.height/crumbleTime;
    b.maxWidth = b.width;
    b.maxHeight = b.height;
    b.trueX = b.xpos;
    b.trueY = b.ypos;
}

function ToActive(){
    b = boxes[boxes.length - 1];
    if(b.isKey){
        unlock(b.keycode);
    }
    else{
        println("ToActive() should be used after the creation of a key to start it activated.");
    }
}

function ActiveKey(keycode,x,y,w,h,c){
    x = round(x);
    y = round(y);
    w = round(w);
    h = round(h);
    boxes.push({xpos:x*5, ypos:y*5, canBeJumped:false, width:w ? w*5 : 30, height:h ? h*5 : 30, color:c ? c : COLOR.GOLD, coll:false, kills:false, keycode:keycode, isKey:true, isLock:false});
    ToActive();
}

function ToForced(){
    b = boxes[boxes.length - 1];
    b.canBeJumped = false;
}

function ToJumpable(){
    b = boxes[boxes.length - 1];
    b.canBeJumped = true;
}

    }};

  // Get the canvas that ProcessingJS will use
  var canvas = document.getElementById("mycanvas"); 
  // Pass the function to ProcessingJS constructor
  var processingInstance = new Processing(canvas, programCode); 
  </script>
</html>
